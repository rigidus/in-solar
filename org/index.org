#+STARTUP: showall indent hidestars

* Overview

Краткая, неполная, и местами неверная схема работы Insolar,
предназначенная для вводных объяснений и "связывания концов".

Логичнее всего объяснять как все работает путем отслеживания прохождения
простого запроса (например на трансфер), но это невозможно без понимания
некоторых концепций работы сети, поэтому придется сделать шаг назад и...

...узнать что сеть Insolar состоит из ~Нод~ и в своей работе опирается на
концепцию ~Пульса~.

~Нода~  - это компьютер в сети, который выполняет для сети какую-то
работу в соответствии со своей ~Ролью~.

~Роль~ - это то какую работу нода делает делает для сети. Иногда роль
ноды может измениться, тогда она начинает делать другую
работу. Существует [TODO:gmm] - Список всех ролей.

~Пульс~ - это некоторый временной отрезок, в течении которого набор нод,
(которые исполняют свои ~Роли~) остается постоянным.

Пульс задают ~Пульсары~, быть пульсаром - это одна из ~Ролей~.

Мы заинтереснованы в корректной работе Пульсаров, потому что если
очередной ~Пульс~ не придет - то вся сеть остановится. [TODO:gmm] - Может
нет? Также новый Пульс содержит энтропию, в соответствии с которой в
новом пульсе будут переназначены ~Ноды~ на выполнение ~Ролей~ - это нужно
для сменяемости нод.  Подробнее: [TODO:gmm] - Работа пульсаров.

Результатом их работы становится [TODO:gmm] - Сообщение о пульсе, которое
распространяется по сети [TODO:gmm] - Как и кем?

Когда ноды получают это сообщение, они прекращают ту работу, которой
занимались согласно выделенной роли, и начинают [TODO:gmm] - Cмену пульса

Теперь когда мы имеем представление о пульсах, можно рассмотреть как
исполняется запрос от пользователя.

* Use-cases

** Transfer

Мы будем рассматривать (простой) запрос о переводе денег от одного
пользователя к другому.

Он начинается с (мобильного) приложения пользователя, которое формирует
запрос и подписывает его ключом пользователя.

Этот запрос отправляется одной из нод сети и попадат на ~BorderContract~.

[TODO:gmm] - Как приложение узнает о нодах сети и их адресах? Как
поддерживается NodeList?

~BorderContract~ - это контракт, который может выполнить любая нода сети,
независимо от того имеет ли она ли она роль ~VirtuelExecutor~ в текущем
пульсе или нет.

Задачи ~BorderContract~:
- проверить подпись запроса
- зарегистрировать запрос пользователя на ~Ledger~ (чтобы не потерялся),
- отправить пользователю подтверждение об этом
- найти нужный контракт, т.е. ~TransferContract~, определить его адрес
- и вызвать его

- [TODO:gmm] - Как регистрируется запрос на ~Ledger~-е?
- [TODO:gmm] - Формат подтверждения и подписывается ли оно
- [TODO:gmm] - Как найти нужный контракт? - процедура
- [TODO:gmm] - Как происходит вызов контракта?

Я предполагаю, что проверка подписи - затратное мероприятие по сравнению
с формированием запроса, поэтому вредоносные приложения могут спамить
ноды запросами с целью нарушить их работу. Поэтому было бы правильно
уравновесить вычислительные затраты на формирование запроса чтобы
избежать этого вектора атаки. Но пока это не сделано.

* Compontents of Platform
* Deployment
* Testing
* Questioons

- Что такое AppController
