#+STARTUP: showall indent hidestars
#+SETUPFILE: https://raw.githubusercontent.com/fniessen/org-html-themes/master/setup/theme-readtheorg.setup


* Intro

Чтобы облегчить процесс понимания того как это все работает, я написал
эту "краткую, неполную, и (вероятно) местами неверную схему работы", в
надежде, что она пригодиться для онбординга и "связывания
концов". Поэтому иногда она пытается вкратце повторить то что разбросано
по другим документам.

Я "обстучал" эту схему об коллег, и постарался составить ее так, чтобы
можно было понять что представляют собой компоненты и как они
взаимодействуют, читая в порядке изложения. Но в нескольких случаях
приходится "забегать вперед". Я старался минимизировать количество таких
случаев, так что если вы будете изменять этот текст, старайтесь чтобы это
количество не росло.

Просьба исправлять ошибки!

* Overview

Insolar - это распределенный вычислитель, использующий в качестве системы
хранения ~DLT~ (distributed ledger technology), распределенный реестр.

Распределенный вычислитель состоит из узлов распределенной вычислительной
сети (~Node~), которые обмениваются запросами (~Request~).

~Request~ - это сетевой запрос от одной Node к другой на выполнение
операции над ~Object~-ом.

~Object~ - это экземпляр ~Смарт-контракта~. Например, конкретный кошелек
какого-то пользователя - это ~Object~, у него собственные данные, такие
как количество денег на балансе, которое, разумеется, у каждого кошелька
свое. Но код, который обрабатывает эти данные - общий для всех кошельков
этого типа. Поэтому у всех ~Object~ одного и того же типа есть один
~Class~, в котором хранится этот код. Таким образом ~Class~ в insolar -
это смарт-контракт. Помимио собственно кода в нем могут хранится,
например, миграции между версиями кода, которые изменяют структуру
~Object~-ов. Это позволяет обновлять ~Object~ в момент, когда к нему
происходит первое обращение новой версии кода.

~Node~ - это компьютер, подключенный к сети, который выполняет для сети
какую-то работу в соответствии со своей ~Role~.

~Role~ - это то какую работу ~Node~ делает для сети. Роли бывают
статические и динамические:
- ~Static Role~ - у каждой Node существует одна и только одна статическая
  роль, назначается при регистрации узла. Она используется системой для
  автоматического назначения ~Dynamic Role~, а так же определяет
  некоторые специальные права узлов.
- ~Dynamic Role~ - действует один пульс и определяет права (и
  обязанности) Node по отношению к конкретной сущности (~Object~, ~Jet~ и
  т.п.). У одной Node ~одновременно может быть множество~ ~Dynamic
  Role~-й, в том числе по одной сущности. Однако, некоторые комбинации
  динамических ролей запрещены. Существует две подкатегории ~Dynamic
  role~:
  - ~Allocated Dynamic Role~ - результат автоматического назначения на
    основе ~Static Role~.
  - ~Delegated Dynamic Role~ - результат полной или частичной передачи
    прав по роли от держателя ~Allocated Dynamic Role~. Переделегирование
    не допускается.
- ~Special Role~ - особые разрешения для Node, не связанные со ~Static
  Role~, но их можно совмещать. Node может иметь ноль и более ролей этого
  типа, они назначаются при регистрации Node.
- (ещё ожидаются роли Cascade и Encrypt)

Нам интересны некоторые часто используемые динамические роли:
- ~VE~, ~Virtual Executor~ - роль Node, которая может в этом пульсе
  выполнять действия с данным ~Object~.
- ~LME~, ~Light Material Executor~ - роль Node, которая в этом пульсе
  производит операции над данными этого ~Object~. Это своего рода кэш
  между ~VE~ и ~HMN~.
- ~HMN~ - постоянное хранилище данных. Пока существует в единственном
  экземпляре.

Этого достаточно чтобы составить себе представление о Roles, необходимое
для дальнейшего объяснения. Более глубокие подробности даны в [[*Node Roles][Node Roles]]

* Pulse

Теперь я начну объяснение с отслеживания пути прохождения ~Request~-а. Но
сначала придется сделать шаг назад и узнать про ~Pulse~.

~Pulse~ - это некоторый временной отрезок, в течении которого набор
~Node~, которые исполняют свои ~Role~, остается постоянным. На каждом
пульсе, для любого выбранной сущности (такой как ~Object~ или ~Jet~)
должна существовать Node с ролью ~VE~, и другая Node с ролью ~LME~.

Когда ~Pulse~ меняется, формируется новый набор узлов, которые будут
выполнять эти роли.

Также ~Pulse~ содержит энтропию, в соответствии с которой в новом пульсе
будут переназначены эти роли - таким образом обеспечивается сменяемость
нод. Этим мы усложняем "сговор" узлов.

Пульс задают ~Pulsar~-ноды. Быть пульсаром - это не одна из ролей, это
совершенно особый тип Node, который занимается только генерацией ~Pulse~.

У нас будет ~Pulsar Network~, который будет использовать распределенный
алгоритм генерации случайного числа, после чего достигают консенсуса в
PBFT-подобном алгоритме и отправляют ~Pulse~ набору случайных нод в
сети. Эти случайные ноды, в свою очередь, распространяют пульс дальше,
своим соседям. В теории, ноды сети не знают где пульсары.

Но в данный момент у нас есть один выделенный пульсар.

Мы заинтереснованы в корректной работе пульсаров, потому что если
очередной пульс не придет - то вся сеть будет продолжать работать в
последнем пульсе, а это не то чего хотелось бы.

Когда ноды получают новый ~Pulse~, они прекращают ту работу, которой
занимались согласно выделенной роли, другую работу. Это называется ~Cмена
пульса~. Например, после смены пульса Node, которая выполняла операции в
предыдущем пульсе, может сохранить результаты своей работы.

Теперь когда мы имеем представление о пульсах, можно рассмотреть как
исполняется запрос.

* Request flow

Мы будем, в качестве примера, рассматривать (простой) запрос (например,
запрос о переводе денег от одного пользователя к другому).

Он начинается с (мобильного) приложения пользователя, которое формирует
~Request~ и подписывает его ~Private Key~ пользователя.

[COMMENT:gmm] Я предполагаю, что проверка подписи - затратное мероприятие
по сравнению с формированием запроса, поэтому вредоносные приложения
могут спамить ноды запросами с целью нарушить их работу. Поэтому было бы
правильно уравновесить вычислительные затраты на формирование запроса
чтобы избежать этого вектора атаки. Решение - как fail2ban только
fail2proof, т.е. увеличивать сложность доказательства.

Этот запрос отправляется одной из нод сети и попадат на ~BorderContract~.

- Как приложение узнает о нодах сети и их адресах, куда отправить запрос?
- В данный момент они захардкожены. Но в будущем за это будут отвечать
  ~Discovery Nodes~, о которых известно всем, а они будут предоставлять
  информацию о адресах нужных нод.

~BorderContract~ - это контракт, который может выполнить любая нода сети,
которая может исполнять код.

У ~BorderContract~-ов есть своя внутренняя машинерия, нацеленная на то
чтобы все ноды, которые могут принять API-запрос знали о
~BorderContract~-ах. Она описана в [[*BorderContracts][BorderContracts]] и
https://insolar.atlassian.net/wiki/spaces/DEV/pages/1009287169/Core+v2+-+VN+-+Custom+APIs

API-запрос содержит:
- адрес объекта (в нашем примере - кошелек)
- имя метода (в нашем примере - transfer)
- поля, зависящие от типа запроса
  - amount (кол-во переводимых денег)
  - to (адрес кошелька, кому переводим)
- seed (против replay-attack). Если повторный запрос будет с уже
  известным seed то он будет отвергнут, т.е. на уровне сети нельзя
  послать один запрос дважды.
- подпись пользователя

Задачи ~BorderContract~:
- опеределить ~UserAddr~ - адрес контракта кошелька пользователя. В
  простейшем случае это можно достать из хэш-таблицы вида pubKey:addr
  которая может лежать на ~LM~ и которую мы можем запросить. Ответ будет
  подписан, поэтому ~LM~ теоретически может быть привлечен к
  ответственности за подлог, но [TODO:gmm] - нужно уточнить у Кирилла
  процедуру распознавания подлога.
- создать ~ctx~ - контекст исполнения запроса - структуру данных, которая
  будет сопровождать запрос, и положить туда ~UserAddr~.
- зарегистрировать ~Request~ на ~LME~ и получить подтверждение этого. Это
  гарантирует что запрос будет исполнен.
- Так как теперь известен адрес контракта кошелька пользователя, то можно
  вызвать этот контракт на текущем ~VE~-е для этого контракта. В
  параметрах передаем ~amount~ из запроса:
  ~wallet.transfer(another_wallet, amount)~

- Как определяется текущий ~VE~ для конкретного объекта?
- Любая Нода, зная текущий Пульс и объект, метод которого вызывается,
  может вычислить ~VE~ по известной функции:
  https://insolar.atlassian.net/wiki/spaces/DEV/pages/826212449/2019-06-18+-+06-21+Request+s+Journey+on+the+Insolar+Network

~VE~ вынимает ~UserAddr~ из ~ctx~ и находит соответствующий текущему
пульсу и адресу ~LM~ и получает от него код контракта и его текущее
состояние.

Для этого сначала надо взять данные ~Object~-а, а для этого вычислить
~Jet~, этого ~Object~-а и его местонахождение - это можно сделать зная
~Jet-Tree~ и список нод ~Light Material~, которые на этом пульсе
работают. Возможно ~VE~ имеет неактуальное ~Jet-Tree~, поэтому когда он
пойдет к ~LM~ руководствуясь неактуальным ~Jet-Tree~, тот даст ему
актуальное ~Jet-Tree~.

- Что такое ~Jet~ и ~Jet-Tree~?
- ~Jet~ - набор данных которые представляют состояние ~Object~-а. Каждый
  ~Jet~ хранится на своем ~Light Material~ узле, поэтому что бы найти
  нужный ~Jet~ нужно ~Jet-Tree~ - бинарное дерево, по которому можно
  сопоставить идентификатор ~Object~ и ~Node~, которая хранит ~Jet~.

В результате ~VE~ попадает к нужному ~LME~, получает данные и отдельным
запросом код. Но сейчас у нас весь код built-in (вкомпилен во все ноды),
поэтому нам пока нужны только данные.

Если у ~LME~ нет этих данных, он запрашивает их у ~HMN~ или даже у одного
из ~LME~ предыдущих пульсов, получает их и кладет себе в кэш.

Однако ситуация отличается, в случае если один ~VE~ вызывает
другой. Такое может произойти, если один контракт хочет вызвать другой,
хоть это и не наш случай, он важен для понимания, поэтому рассмотрим
его. Тогда вызываемый ~VE~ знает что у вызывающего ~VE~ уже есть все
необходимые данные и новый ~VE~ может (и должен) получить их у
старого. Таким образома система не упирается в скорость обмена с ~LME~.

* Contract execution

Теперь все готово, чтобы начать исполнение контракта.

Теперь начинает работать контракт кошелька пользователя. Для трансфера он
должен:
- зарегистрировать ~incomming request~ на своем ~LME~ и получить
  подтверждение регистрации.
- проверить, что пользователь имеет право переводить деньги с кошелька -
  это можно проверить через принадлежность кошелька пользователя
  (например, в объекте кошелька может быть указание на owner-a и тогда мы
  сверяем от чего имени идет исполнение с этим owner-ом)
- проверить что на кошельке хватает баланса
- уменьшить свой баланс на сумму перевода
- вызвать на целевом кошельке метод accept на эту сумму
  (~target.accept(amount)~) Это исходящий SAGA-вызов - он помечен
  аннотацией. Т.к. это исходящий SAGA-вызов (google:"saga pattern") - он
  просто регистрируется на ~LME~ но его исполнение откладывается.
- контракт успешно завершается, на ~LME~ сохраняется его ~Result~ и его
  новое состояние
- в этот момент ~LME~ триггерит запуск SAGA-вызова и исполнение
  продолжается на новом ~VE~ который является текущим в этом пульсе для
  целевого кошелька.
- ~VE~ целевого кошелька сохраняет ~incomming request~ на своем ~LME~ и
  начинает его исполнение

В дальнейшем SAGA может иметь механизм ~rollback~, который заключается в
том, что на исходящей части SAGA-вызова к методу ~accept~ целевого
кошелька будет добавлен метод ~rollback~ (с теми же параметрами что и
~accept~), который будет зарегистрирован на кошельке пользователя, если
accept по какой-то причине не прошел. [TODO:gmm] - Кто должен сделать
регистрацию?

[TODO:gmm] Code Owner = Саша Алексеев. Где этот код?

Завершение исполнения приводит к обновлению данных на ~LME~ целевого
кошелька и мы ([TODO:gmm] - каким образом?) оказываемся снова в
~BorderContract~, который возвращает приложению пользователя информацию о
том что транзакция выполнена (именно транзакция, потому что запрос
фактически был выполнен еще до того как началась обработка SAGA-вызова)

- Как регистрируется запрос на ~Ledger~-е?
- Когда ~VE~ получает входящий запрос, он регистрирует ~incomming
  request~ на своем ~LME~ для этого объекта.
- Когда ~VE~, исполняя контракт, хочет сделать вызов, он сначала на своем
  ~LME~ создает ~outgoing request~, после этого посылает другому ~VE~
  запрос, и этот другой ~VE~ регистрирует на своем ~LME~ ~incomming
  request~. Вызывающий ~VE~ ожидает возврата, таким образом, это
  синхронный вызов. Если какой-то ~LME~ зависнет, то ~VE~ будет ждать на
  этом вызове до окончания пульса. Но остальные объекты будут продолжать
  обрабатываться.
- Существуют еще асинхронные ~NoWait~ вызовы. Они не ожидают возврата, но
  пока таких нет.

- [TODO:gmm] - Retryable Error. Увеличение счетчика попыток для
  запроса. Найти в VN-PROTOCOL в конфле. Там же есть оптимизации для
  скорости не ходим к лайту на каждый чих, а регистрируем ~incomming~ и
  ~outgoing~ в одной пачке, если нет исходящих вызовов.
  https://insolar.atlassian.net/wiki/spaces/DEV/pages/1010630790/Core+v2+-+VN+-+Error+Classification

* Data storage

После окончания пульса ~LME~ делает ~JetDrop~ - т.е. сохраняет данные на
~HMN~ и на некоторое время (light-stash-limit) становится ~LMS~ - ~Light
Material Stash~. Это значит что он хранит данные и отдает их в ответ на
запросы. После окончания light-stash-limith он удаляет эти данные и
дальше их можно будет найти только на ~HMN~.

~JetDrop~ сохраняется в ~Jet~-ы, для каждого ~Object~-а - свой
~Jet~. Сохраняемые данные состоят из ~Record~-ов, каждый из которых
представляет состояние ~Object~ в какой-то временной точке.

~Record~ - это некоторый (подписанный создавшей его нодой) набор данных,
адресуемый через свой ~hash~ и номер ~Пульса~. Например ~Request~ и
~Result~ - это ~Record~-ы. Он также может содержать ссылку на другой
~Record~ объединяясь, таким образом, в цепочку. Такой цепочкой является
~LifeLine~. Данные ~Object~-а состоят из ~Lifeline~ и ~Filament~-ов.

~Filament~ - это одна из цепочек внутри ~Object~-а. ~Object~-ов в одном
~Jet~-е много. У объекта может быть несколько филаментов, например:
- его состояния
- запросов/ответов к нему
- его дочерних объектов

~Virtual Jet~ - это набор афинных ~Object~-ов, т.е. объектов, которые
хранятся (в рамках ~Material Jet~) и исполняются (это важнее)
вместе. Т.е. много разных объектов, которые принадлежат к одному ~Jet~-у
(потому что у них id начинается на одну цифру) будут храниться
вместе. ~Virtual Jet~ - это история про исполнение: например делегаты
будут всегда исполняться там же где их родитель. Делегат - это что-то
типа объекта-плагина, привязанного к основному объекту. Например, если
существует объект User то его кошелек может быть реализован как
делегат. Тогда, помимо того что он будет исполняться там же где и User,
кошелек можно будет адресовать через родительский объект. Это позволяет
получать объект типа "А" как объект интерфейса "Б". Делегаты пока не
реализованы. [TODO:gmm] - уточнить у Кирилла, правильность всего этого.

~Message~ - это сетевое представление ~Record~-а, состоящего из одного
или более ~Record~-ов. Оно состоит из:
- ~Message Head~ - поднабор полей, который будет передан получателю сразу
  при отправке. Этот поднабор должен влезать в UDP-пакет вместе со своей
  подписью.
- ~Message Content~ - все что не влезло в ~Message Head~.
https://insolar.atlassian.net/wiki/spaces/DEV/pages/1080295571/Core+v2+-+Messages

Несколько ~Message~ могут быть посланы бандлом, т.е. в одной сетевой
посылке.

* Jet split and merge

Изначально существует один ~Jet~ и все данные пишуться в него. Как только
размер данных на протяжении нескольких пульсов превышает определенный
порог - он разделяется на два, этот процесс называется ~split~. Таким
образом формируется дерево ~Jet~-ов.

Теперь у нас 2 ~Jet~-а, и отсплитившийся ~Jet~ может быть передан другому
~LME~. Если на старый ~LME~ за данными из отсплитившегося ~Jet~-а придет
~VE~, то ему будет сообщено, что он должен переадресовать свой запрос
этому другому ~LME~ и так продолжится рекурсивно, пока данные не будут
найдены.

Обратный процесс - слияние разсплитившихся ~Jet~-ов. Случается когда
размер данных в течении некоторого времени ниже определенного порога.

* Передача через пульс

Если во время выполнения ~Request~-а меняется пульс, то с момента смены
пульса текущий ~VE~ не может продолжать исполнение, потому что в новом
пульсе он уже не является ~VE~ для этого объекта. И валидаторы не
пропустят и другие ноды когда проверяют может ли эта нода исполнять
запрос увидят что не может.

Поэтому бывший ~VE~ вычисляет новый ~VE~ по своему объекту и сообщает
новому ~VE~ что продолжает исполнение и ему нужен ~Delegation
Token~. Новый ~VE~ проверяет, что в прошлом пульсе старый ~VE~ был ~VE~
по этому объекту и выдает этот токен, подписывая его. После чего бывший
~VE~ продолжает исполнение, прикладывая к каждому внешнему вызову этот
токен. Получатель вызова проверяет подпись токена и видит что бывший ~VE~
может это исполнять.

Если и новый пульс закончился, то бывший ~VE~ может опять сходить к еще
более новому ~VE~, приложив свой предыдущий токен и получить свежий
~Delegation Token~. Такое можно повторять до истечения лимита пульсов на
запрос. Если лимит истек, то новый VE отказывает в выдаче токена и
начинает исполнять запрос самостоятельно с самого начала, но
переиспользует сохраненные результаты предудыщих вызовов за счет
"Механизма дедупликации". Это механизм, который регистрирует внешние
вызовы на лайте и если вызов с таким Reason и параметрами (и с тем же
счетчиком) уже был сделан и результат его записан, то не нужно его
повторять.

Когда мы пытаемся дедуплицировать запрос мы можем иметь три состояния
- такого запроса не было - его на до исполнять
- такой запрос был, но результата нет - запрос не регистрируется (так как
  уже зареган), но начинает исполнение
- такой запрос был и есть записанный результат

Этот механизм позволяет сильно ускорить валидацию. В рамках валидации
проверятся, что все вызовы были сделана и проверяются результаты вызовов

Как происходит (будет происходить) валидация:
- ~Request~ был зарегистрирован, исполнен, завершен и записан, его можно
  валидировать
- Валидаторы берут его, с темы же значениями и выполняют как бы "в том же
  пульсе" (но на самом деле они работают в следующем пульсе)
- Плюс к этому, валидаторы проверяют всю цепочку вызовов, и их ~Reason~-ы

* TODO Компоненты

https://insolar.atlassian.net/wiki/spaces/DEV/pages/737935598/Insolar+Interconnection+Model

https://insolar.atlassian.net/wiki/spaces/DEV/pages/1092517974/Core+v2+-+Compartments+and+APIs



** Networkd

- Отвечает за конценсус, валидацию нового пульса и формирование
  population для этого пульса
- Передает валидный пульс и population для него в insolard (В варианте
  multi-globule network это поведение изменится)
- Отправляет и получает сообщения из сети

* TODO Старт ноды

https://insolar.atlassian.net/wiki/spaces/DEV/pages/891781148/Core+v2+-+Network+Isolation

https://insolar.atlassian.net/wiki/spaces/DEV/pages/1059979386/Core+v2+-+AppController+design

* TODO Unsorted

[TODO:gmm] Jet|Jet-tree Code owner = Романцев. В 2.0 этого когда не
будет, потому что там все переделывается, пока неясно как.

[TODO:gmm] - Высоконагруженные объекты среди слабонагруженных - дописать

[TODO:gmm] Jets, Filaments, Etc - искать в конфле по Романцеву

[TODO:gmm] Консенсус. Работает в паралельном процессе и имеет более
высокий приоритет, чем остальные вещи. Поэтому теперь выделен в соседний
бинарь, чтобы обработка сетевых запросов не могла затормозить
time-critical задачи консенсуса. Предоставляет ActiveList.

[TODO:gmm] Join ноды в сеть: Изначально предполагалось, что ноды будут
сами джойнить друг друга, но этот механизм оказался сложным в реализации
и тестировании, поэтому решили пока сделать упрощенный алгоритм.
- бутстрап через хэвик - через него все зарегиструются
- дискавери нода подключает хэвик
- механизм бутстрапа будет меняться

[TODO:gmm] - PulseAppender?

[TODO:gmm] - Validation?

Каждый пульс сохраняется на LME как ~JetDrop~, который представляет собой
изменившиеся состояния каждого объекта. ~Material Node~ выполняет
хранение данных, так как они подписаны, они неизменны и иммутабельны,
однако [TODO:gmm] - что будет если хранилище не запишет, посланные ему
~Record~-ы?
- Для этого в 2.0 будем вводить Light-реплики

~Lifeline~ - это последовательность объектных ~Record~-ов.  Подробнее:
https://insolar.atlassian.net/wiki/spaces/DEV/pages/784891920/Data+Model#DataModel-Object

Чтобы отправлять ~Record~ он упаковывается в ~Message~.

[TODO:gmm] - Как поднимается сеть (Network 101) - дописать по интерьвью с
Андреем

* Compontents of Platform
** Platform Core
*** Network
**** Node Roles

Виды ролей и связь их с узлами

***** Static Roles

Static Role одна и только одна на узел.

Колонка “гранулярность” в таблице определяет относительно чего
назначаются dynamic roles для узла в соответсвующей статической роли.

| Static Role          | Application Function                                 | Granularity of Dynamic Allocation                                    |
|----------------------+------------------------------------------------------+----------------------------------------------------------------------|
| Neutral (NN)         | Не специфицирована, не выполняющие работы уровня L4+ | Не специфицирована, не выполняющие работы уровня L4+                 |
| Heavy Material (HMN) | Долгосрочное хранине                                 | Material jet segments (набор последовательных drop'ов в одном jet'е) |
| Light Material (LMN) | Запись и краткосрочное хранение drop'ов              | Jet drop'ы / Jet-affined                                             |
| Virtual (VN)         | Вычисления и краткосрочное хранение object'ов        | Object'ы / Object-affined                                            |

***** Dynamic Roles

~Важно~! помнить:

- Динамическая роль назначается конкретному узлу, на конкретный пульс и
  на конкретную сущность (request, object, jet, segment).
- Один узел на один пульс получает множество динамических ролей, в том
  числе и для одной сущности, например: LME(A, P) и LMS(A, P-1).

******* Dynamic Role Targets

Существуют следующие категории сущностей для динамической аллокации
(Dynamic Role Targets):

- Virtual jet - обычно упоминается как object / lifeline. Особенность в
  том, что связанные (афинные объекты) не могут исполняться отдельно и
  обозначение VE(A, P) говорит, не только об исполнителе для A, но и для
  всех афинных ему объектов.
- Material jet - обычно упоминается как jet. Это группа храненения для
  virtual jets, сформированная на основе текущего jet tree. Для каждого
  объекта на конкретный пульс всегда однозначно определяется jet.
  - В результате работы LME, по каждому jet'у за пульс будет сформирован
    блок записей - jet drop.
- Material jet segment - последовательность связанных jet drop'ов
  относящихся к одному jet'у (или к его производным после split/merge),
  сохранённая одним HME и хранимая как неделимый набор данных.
  - Хранение в виде сегментов предназначено для упрощение учёта хранения
    и контроля за распространением данных.
  - Requests - запросы. Это обобщающая категория, когда узел не передаёт
    свою динамическую роль, но делегирует часть полномочий на исполнения
    конкретной операции произвольному узлу.

|                                                | Request           | Virtual Jet (object and its affined ones) | Material Jet                    | Material Jet Segment                                                        |
|------------------------------------------------+-------------------+-------------------------------------------+---------------------------------+-----------------------------------------------------------------------------|
| Automatically allocated to                     | NA                | VN                                        | LMN                             | HMN                                                                         |
| Allocation Function                            | NA                | Entropy + ActiveNodes                     | Entropy + ActiveNodes + JetTree | Entropy + ActiveNodes + LME/LMS approval                                    |
| Automatically allocated node ~can delegate to~ | Any ~known*~ node | Any ~active~ node                         | Any ~active~ node               | Any known* HMN                                                              |
| Restrictions                                   | None              | (1)                                       | (1)                             | Аналогично material jet, плюс ограничения по Scattering и Replication rules |
| Dynamic Roles                                  | NA                | (2)                                       | (2)                             | (2)                                                                         |


(1) VE(A, Pn) не может быть VV(A, Pn), т.е. исполнитель не может быть
валидатором для своих результатов. См. ниже.  (2) Executor (*E), Replica
(*R), Validator(*V), Stash(*S) *known node - узел за пределами текущего
консенсуса, но который можно аутенцифицировать и авторизовать (есть ключ
и т.п.)

***** Allocation Restrictions

Возможно два уровня ограничений на совмещение одноим узлом ролей по одной
сущности:

- Обязательный - исполнитель (*E) не может быть автоматически выбран на
  роль валидатора (*V) для проверки собственных результатов. Это
  ограничение действует безусловно, функция выбора валидаторов не долна
  включать узел, вычисленный как *E.  [NOTE] Это так же должно
  распространяться и на делегатов, но в ограниченной
  форме. Т.к. делегирование выполняется по запросам, то если делегат
  попал в валидаторы, то необходимо, чтобы для каждого делегированного
  запроса было достаточно валидаторов, не считая делегата, его
  выполнившего.
- Расширенный - если для пульсов P и P-1 исполнителем *E выбран один и
  тот же узел, то для P узел обязан сделать полное делегирование роли на
  следующий (с т.з. allocation function) узел. Данное поведение
  форсируется через *V (откажут в проверке).  Для VE это так же
  форсируется через LME (примет только регистрацию полной делегации).

Такое поведение необходимо, чтобы функция вычисления исполнителя не
требовала рекурсии по истории аллокаций. Любой другой узел всегда
однозначно вычисляет *E, а в случае такой ситуации - получит от *E
переадресацию на делегата.

***** Special Roles

В настоящий момент используется только одна специальная роль:

- Discovery - узел, используется для подключения к сети узлов, с
  неактуальным списком активных узлов.

В дальнейшем появится роль Dynamic Discovery.

*** BorderContracts

#+NAME:
#+BEGIN_SRC plantuml :file ../img/uml-border-contract.png :eval no-export
  @startuml participant C as "RPC Client" order 10 participant S as "RPC
  Server" order 20 participant V as "Virtual Node" order 30 == Pulse
  change == S <- : CommitPulse(PN) S -> S : SeqN = FirstSeqN =
  Rand.UInt()\nmapSecrets[PN] = SecretN = Rand.UInt() ...  C -> S :
  getSeed() activate S S -> S : seed = [PN, SeqN, hash(PK, SeqN,
  mapSecrets[PN])]\nmapSeeds[PN][SeqN]=1\nSeqN++ S -> C : seed deactivate
  S note right of S To keep seeds:
  - PN, FirstSeqN, SecretN
  - bitmap[# of SeqN]
  => ~13kB per 100k seeds end note note right of S NB! Seed generation &
  load balancig can be done on a separate server. Then the seed should be
  extended by adding [mapSecrets[PN], FirstSeqN] encrypted by target's
  PK.  end note ...  C -> S : apiCall(payload[seed, endpoint, callSite])
  activate S S -> S :
  assert(mapSeed[seed.PN][seed.SeqN]==1)\nassert(seed.hash == hash(PK,
  seed.SeqN, mapSecrets[seed.PN])\nmapSeed[seed.PN][seed.SeqN]=0 V \->
  S : facade = getEndpointFacade(endpoint) // cacheable S -> S :
  facade.preValidatePayload(payload) V \-> S : slotId :=
  conveyor.AddInput(incomingExternal, payload, validation) S -> C :
  queueId = [PN, slotID, hash(payload)] note right of C Can also include
  sign(PK(VN), hash(queueId)) to prevent MitM end note deactivate S
  activate V note right of V SM for the request end note V -> V :
  identity = validateIdentity(payload) // can call e.g. Kerberos V -> :
  extCallRef = registerExternalIncoming(payload) +
  \nregisterImpersonatedOutgoing(payload, identity) ...  V ->x V : stop
  deactivate V S \-> C : (get a new seed)\nstatus =
  apiCallStatus(payload[new_seed, queueId]) note right of S apiCallStatus
  will reject too old PNs, then it goes into 4 ways:
  1. (current PN) will look for an SM by slotID
  2. (past PN) will look for an SM, then in a special cache by slotID
  3. (antique PN) will create a special SM to find a registration record by [PN, hash(payload)]
  end note @enduml #+END_SRC

#+results:
[[file:../img/uml-border-contract.png]]


[[file:../img/uml-border-contract.png]]

** Ledger
** Virtual Machines
** Smart Contracts
** Platform API
** Observer
** Business Foundation
** Application
* Deployment

- [TODO:gmm] - Как развернуть сеть с нуля
- [TODO:gmm] - Как протестировать что-то на развернутой сети
- [TODO:gmm] - Как обновлять
https://insolar.atlassian.net/wiki/spaces/DEV/pages/1038221313/WIP+Insolar+Kubernetes+Deploy+Design

* Testing
* Добавление/удаление нод
* Questioons

- Что такое AppController
  AppController - это функциональность внутри утилиты insolard, которая
  занимается запуском компонентов в нужной конфигурации и выбором схемы
  взаимодействия между этими компонентами.
  https://insolar.atlassian.net/wiki/spaces/DEV/pages/1059979386/Core+v2+-+AppController+design
  AppController нужен для простого и быстрого создания различных
  конфигураций ролей и сети для локального запуска. Цель получить один
  процесс, к которому можно подключиться дебаггером.

- Что такое Scheduler-сервис
  - Узнал отсюда:
    https://insolar.atlassian.net/wiki/spaces/SAIV/pages/1070071873/WIP+Scheduler
- SAIV
- SAGA
  https://microservices.io/patterns/data/saga.html [TODO:gmm] - актуальна
  ли saga для assured ledger?

* Other

Объект хранится в виде Лайфлайна. Первая запись в Лайфлайне это
постоянный адрес этого Объекта.

Объекты могут быть разных типов, но в основном это "Смарт
Контракты". Время жизни объекта, обычно, не ограничено и контролируется
только самими Объектом или его Доменом.

Объект является свободным, в случае если его привязка к Jet зависит
только от самого объекта (а не от других объектов)

Объект является аффинным другому объекту, в случае если его привязка к
определенному Jet зависит от привзяки другого (свободного или аффинного
другому объекту) объекта




@eugene.blikh в какой SM обрабатывается вызов? И как эти SM связаны с SM
объекта?  44 replies Eugene Blikh:press-f-2: 2 hours ago все внешние
вызовы попадают сначала в SM из sm_request (в init.go находится роутер
сообщение -> тип стейт машины)далее (на примере call method) машина
обращается к объекту используя “useSharedObjectInfo” функцию (которая
закидывает то что ей нужно сделать в “контекст” объекта, на самом деле
которая получает доступ к расшаренному состоянию объекта) Ruslan Zakirov
2 hours ago перефразирую: Ruslan Zakirov 2 hours ago сам запрос
(сообщение) обрабатывается в своем инстансе SM обработки вызовов, также
есть инстанс SM “объектов“, который шарит данные общего доступа для
исполнений Ruslan Zakirov 2 hours ago так?  Eugene Blikh:press-f-2: 2
hours ago все так, да Eugene Blikh:press-f-2: 2 hours ago а почему вы
спрашиваете?  Ruslan Zakirov 2 hours ago хочу понять состояние мира и как
привести его к состоянию будущего :slightly_smiling_face: Ruslan Zakirov
2 hours ago а ты произнес этот вопрос со специальным выговором?
:slightly_smiling_face: Eugene Blikh:press-f-2: 2 hours ago нет, конечно,
это было-бы токсично Eugene Blikh:press-f-2: 2 hours ago
:goose:
Ruslan Zakirov 1 hour ago вот запрос (сообщение) обрабатывается в своем
инстансе SM1 обработки вызовов, сделали непосредственно вызов к VM через
адаптер и SM1 перешла в состояние ожидания результата исполнения. Как
приходит результат? (edited) Eugene Blikh:press-f-2: 1 hour ago результат
попадает в общую SM для всех таких сообщений.  дальше он должен понять -
является ли он ответом на запрос (и если является, то найти SM по
глобальному списку где будет лежать верный barge-in коллбек, который мы
исполняем) (edited) Eugene Blikh:press-f-2: 1 hour ago врываемся в нужную
SM которая ожидает ответа и передаем туда ответ Ruslan Zakirov 1 hour ago
должен понять != понимает. это то как работает уже?  Eugene
Blikh:press-f-2: 1 hour ago сейчас это работает через адаптер полностью,
у нас у сообщения есть понимание того является ли это response или нет
Eugene Blikh:press-f-2: 1 hour ago а в целом почему не понимает? есть
какое-то объяснение этому? (edited) Ruslan Zakirov 1 hour ago это != было
про фразу, что она звучала как что-то незавершенное Ruslan Zakirov 1 hour
ago звучало как “должен понять, но пока не так…”  Ruslan Zakirov 1 hour
ago вернись к моему вопросу…  Eugene Blikh:press-f-2: 1 hour ago ну не
знаю, всегда есть признаки по которым можно понять возможно это не
проработано и надо прорабатывать для каждого отдельного случая Ruslan
Zakirov 1 hour ago я говорил про вызов к коду контракта, а не про внешний
вызов от одного контракта к другому Eugene Blikh:press-f-2: 1 hour ago
наприер: GetObject -> мы публикуем “response-<objectid>” и ждем ответа ->
приходит Index/Lifeline в каждом из которых есть objectid -> находим в
табличке “respnse-<objectid>” и передаем (edited) Eugene Blikh:press-f-2:
1 hour ago ааааа Eugene Blikh:press-f-2: 1 hour ago простите, недопонял
Eugene Blikh:press-f-2: 1 hour ago сейчас опишу Ruslan Zakirov 1 hour ago
выглядит как тоже самое, только без сообщения из сети, а локальное
создание SM и далее возврат результата через barge-in Eugene
Blikh:press-f-2: 1 hour ago сейчас все тоже через адаптер Eugene
Blikh:press-f-2: 1 hour ago но да, в целом ты прав Eugene
Blikh:press-f-2: 1 hour ago как и сетевая часть Eugene Blikh:press-f-2: 1
hour ago надо только понимать что ответ может вернуться “сделай мне
внешний вызов“, а не только “вот результат” (edited) Ruslan Zakirov 1
hour ago вот это меня тоже интересовало, но это был бы следующий вопрос
Ruslan Zakirov 1 hour ago когда ты упоминаешь “сейчас через адаптер“, то
что это значит? ты несколько раз эту фразу написал.  Eugene
Blikh:press-f-2: 1 hour ago адаптер блокирует исполнение SM пока не
придет один из двух результатов Eugene Blikh:press-f-2: 1 hour ago а не
SM запускает вызов через адаптер и засыпает сама в ожидании пока ее
разбудит Eugene Blikh:press-f-2: 1 hour ago грубо говоря можно уснуть
пока нас не разбудит адаптер, а можно уснуть пока нас не разбудит другая
компонента Eugene Blikh:press-f-2: 1 hour ago например через barge-in или
другую компоненту Eugene Blikh:press-f-2: 1 hour ago

s.ContractRunner.PrepareAsync(<code>).DelayedStart().Sleep().ThenJump(<code>)

дождаться пока адаптер завершит исполнение и затем проснуться Eugene
Blikh:press-f-2: 1 hour ago ack?  Ruslan Zakirov 1 hour ago хммм Eugene
Blikh:press-f-2: 1 hour ago я понимаю что это звучит как то, что может
сбивать с толку, так что буду рад любым вопросам Ruslan Zakirov 1 hour
ago зачем нам bargin тогда? вызвали адаптер и спим всегда Eugene
Blikh:press-f-2: 1 hour ago по задумке адаптер может фильтровать
пропускную способность Eugene Blikh:press-f-2: 1 hour ago если она
превышает возможную, то тут надо принимать меры Ruslan Zakirov 1 hour ago
спасибо

#+NAME:
#+BEGIN_SRC go
    package main

    import ( "fmt" "github.com/pkg/errors" "go/ast" "go/parser"
        "go/token" "io/ioutil" "os" "reflect" "strings" )

    const ( TemplateDirectory = "templates"

        //filename =
        "src/github.com/insolar/assured-ledger/ledger-core/v2/conveyor/smachine/ping-pong/example/example_3.go"
        filename =
        "src/github.com/insolar/assured-ledger/ledger-core/v2/logicrunner/sm_object/object.go"
        mainPkg = "main" errorType = "error" MachineTypeGoPlugin )

    type RecvPair struct { Name string Type string } #+END_SRC

* Tasks

blins gilses spichki vopros-for-kirill rope docs for:
- masha
- ilya Ilya Ozherelyev Запись разговора :)
- OKR https://docs.google.com/presentation/d/1skBq7QOH4ABE2YqanjkGu1BXJPRq5JNO3cWbwfQC8X8/edit#slide=id.g7670151903_14_683

Ruslan Zakirov Today at 3:54 PM @kirill.ivkushkin @mikhail.glukhov
@eugene.blikh у нас есть пример в confluence обработки timeout ситуаций
на конвейере? может в коде?  54 replies Kirill
Ivkushkin:house_with_garden: 34 minutes ago а для какой ситуации?
(edited) Ruslan Zakirov 34 minutes ago ушли в адаптер, ждем сообщения с
ответом, timeout на это ожидание Kirill Ivkushkin:house_with_garden: 33
minutes ago а зачем?  Kirill Ivkushkin:house_with_garden: 33 minutes ago
придёт пульс и всё решит Kirill Ivkushkin:house_with_garden: 33 minutes
ago или ты про опрос пред VE? (edited) Ruslan Zakirov 33 minutes ago
получение стейта от VE(P-1) Kirill Ivkushkin:house_with_garden: 33
minutes ago ага, тогда ща Ruslan Zakirov 31 minutes ago стоп, а чем этот
кейс отличается от других и почему не “придёт пульс и всё решит“?
:slightly_smiling_face: (edited) Eugene Blikh:press-f-2: 31 minutes ago
было решено оставлять блокирующие адаптеры?  Kirill
Ivkushkin:house_with_garden: 32 minutes ago никаких блокирующих Ruslan
Zakirov 31 minutes ago нет, не блокирующие Ruslan Zakirov 31 minutes ago
под “ждем” я имел ввиду стейт SM, а не блокировку в адаптере Kirill
Ivkushkin:house_with_garden: 30 minutes ago этот кейс отличается тем, что
тут речь о параллелизмне разных запросов состояния, но для оптимизации,
надо один из запросов задержать Kirill Ivkushkin:house_with_garden: 30
minutes ago чтобы не создавать лишней "движухи" Kirill
Ivkushkin:house_with_garden: 29 minutes ago т.е. здесь не таймаут на
ожидание ответа (таких не должно быть), а таймаут на ожидание перед
отправкой / следующим шагом Kirill Ivkushkin:house_with_garden: 29
minutes ago так вот Kirill Ivkushkin:house_with_garden: 29 minutes ago
про ожидание Kirill Ivkushkin:house_with_garden: 29 minutes ago
https://insolar.atlassian.net/wiki/spaces/DEV/pages/1092452459/Core+v2+-+Conveyor+-+Brief+Intro+Example#%D0%9F%D0%BE%D0%B2%D1%82%D0%BE%D1%80-%D1%82%D0%B5%D0%BA%D1%83%D1%89%D0%B5%D0%B3%D0%BE-%D1%88%D0%B0%D0%B3%D0%B0-(Repeat)
Kirill Ivkushkin:house_with_garden: 28 minutes ago см второй пример кода
Kirill Ivkushkin:house_with_garden: 28 minutes ago где WaitAnyUntil
Ruslan Zakirov 25 minutes ago Посмотрел Ruslan Zakirov 21 minutes ago Я
не помню как ctx.WaitAnyUntil прерывается ответом?  Ruslan Zakirov 21
minutes ago И еще Ruslan Zakirov 21 minutes ago Как ThenRepeatOrJump
выбирает что сделать. Repeate или Jump?  Kirill
Ivkushkin:house_with_garden: 20 minutes ago если надо что-то проверять
при ожидании (например наличие ответа), то надо или завести соотв флаг и
его проверять в начале метода, или проверять счётчик запросов - см тут
https://insolar.atlassian.net/wiki/spaces/DEV/pages/1092452459/Core+v2+-+Conveyor+-+Brief+Intro+Example#%D0%9F%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D1%80%D0%B5%D0%B7%D1%83%D0%BB%D1%8C%D1%82%D0%B0%D1%82%D0%B0
Kirill Ivkushkin:house_with_garden: 19 minutes ago т.е. код будет а-ля
Kirill Ivkushkin:house_with_garden: 16 minutes ago Untitled

func (p *PlayerSM) stepNextGame(ctx smachine.ExecutionContext)
smachine.StateUpdate {

  ...

    // take a small break

    sleepUntil := time.Now().Add(time.Millisecond *
    time.Duration(rand.Intn(500)))

    // here we use closure to avoid putting (sleepUntil) into SM's state

    return ctx.Jump(func(ctx smachine.ExecutionContext)
    smachine.StateUpdate {

        if p.hasState {

            return ctx.Jump(p.stateIsReady)

        }

        return
        ctx.WaitAnyUntil(sleepUntil).ThenRepeatOrJump(p.stepFindPair)

    })

}

Ruslan Zakirov 15 minutes ago Эту часть я понял. Ты повторил пример кода
из confluence.  Kirill Ivkushkin:house_with_garden: 14 minutes ago я
вписал if Ruslan Zakirov 14 minutes ago ок Kirill
Ivkushkin:house_with_garden: 14 minutes ago

       if p.hasState { return ctx.Jump(p.stateIsReady) }

Ruslan Zakirov 14 minutes ago вижу Ruslan Zakirov 12 minutes ago не
отвечает на вопрос “как ctx.WaitAnyUntil прерывается ответом?“, то есть
не понятно почему мы не будем ждать лишнее время в этом Wait, когда
“ответ” нам доставили Kirill Ivkushkin:house_with_garden: 12 minutes ago
по ответу сработает callback, внутри callback ты поставишь флаг и
сделаешь WakeUp и SM будет активирована сразу, проверит флаг и пойдёт по
своим делам дальше (edited) Kirill Ivkushkin:house_with_garden: 11
minutes ago там внутри в этой функции нету sleep'а (edited) Ruslan
Zakirov 9 minutes ago пока понятно Ruslan Zakirov 10 minutes ago callback
я регаю где? в bargein? (блин никак не запомню спелинг) (edited) Kirill
Ivkushkin:house_with_garden: 9 minutes ago если для побудки из вне, то
да, через bargeIn Kirill Ivkushkin:house_with_garden: 7 minutes ago можно
даже жёстче - можно сделать bargeIn с джампом Kirill
Ivkushkin:house_with_garden: 6 minutes ago и привязать к шагу Ruslan
Zakirov 6 minutes ago прикольно Ruslan Zakirov 6 minutes ago достаточно
Mikhail Glukhov 5 minutes ago я не понял, как сделать bargein с джампом и
почему это сработает, но хочу понять Kirill Ivkushkin:house_with_garden:
5 minutes ago

NewBargeInThisStepOnly().WithJump(...)

(edited) Kirill Ivkushkin:house_with_garden: 4 minutes ago соотв, шаг не
сменился, вызов bargein пробудит машину и принудительно поменяет ей шаг
Kirill Ivkushkin:house_with_garden: 4 minutes ago но если шаг сменился
(от того, где был создан такой bargeIn), то такой bargein будет
проигнорен (edited) Kirill Ivkushkin:house_with_garden: 3 minutes ago это
не почему - это как :slightly_smiling_face: Kirill
Ivkushkin:house_with_garden: 3 minutes ago так он себя ведёт Ruslan
Zakirov 2 minutes ago я приблизительно понял про bargein с фиксированным
шагом Kirill Ivkushkin:house_with_garden: 1 minute ago тоже самое можно и
для вызова адаптера Ruslan Zakirov 1 minute ago “т.е. здесь не таймаут на
ожидание ответа (таких не должно быть), а таймаут на ожидание перед
отправкой / следующим шагом” - это ты имел ввиду, что мы должны подождать
прежде чем шлем VStateRequest к VE(P-1), а вдруг сам пришлет?  Kirill
Ivkushkin:house_with_garden: 1 minute ago ага Ruslan Zakirov < 1 minute
ago ок, я отмечу Kirill Ivkushkin:house_with_garden: < 1 minute ago
спасибо
