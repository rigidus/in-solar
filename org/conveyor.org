#+STARTUP: showall indent hidestars
#+SETUPFILE: https://raw.githubusercontent.com/fniessen/org-html-themes/master/setup/theme-readtheorg.setup

* Зачем это все

Для обработки входящих ~Request~-ов, таким образом, чтобы максимально
скрыть особенности обработки от ~SM~. Плюс избавить разработчика от
проблем синхронизации и контроля параллелелизма.

* Сущности и их определения и связи

~State Machine~, ~SM~ - это конечный автомат, реализованный как класс,
где состояния конечного автомата определены как методы этого класса. С
точки зрения разработчика SM - это именно состояния и переходы между
ними.

Для обслуживания ~SM~ определена сущность ~Slot~, которая является
диспетчеризирующей оберткой вокруг SM. Можно сравнить ~Slot~ с Process
Control Block - блок данных с информацией о процессе операционной
системы, тогда ~SM~ в этой аналогии будет процессом. Каждый ~Slot~ связан
со своей ~SM~, а в диспетчере единицей учета является именно ~Slot~.

~Slot Machine~ - это и есть такой диспетчер. Он распределяет между
слотами время исполнения.

Обычно в одно и то же время работают несколько (три) таких диспетчера
(~Slot-Machine~) - для прошедшего, настоящего и будущего пульса. Во всех
трех случаях логика работы немного отличается (как?).

Каждая из этих ~Pulse Slot Machine~ связывается со своей сущностью ~Pulse
Slot~. ~Pulse Slot~ также обслуживает логику изменения ~Pulse~, это
реализуется как своя ~SM~ на каждой ~Pulse Slot~, а к ней уже
привязывается ~Slot Machine~, в которой ~Slot~-ы и в каждом ~Slot~-е своя
~SM~.

~Conveyor~ - это диспетчер над несколькими ~Pulse Slot~ такой же как
~Slot-Machine~ - диспетчер над несколькими ~Slot~.

Если приходит ~Request~, то дергается метод ~Conveyor~-а, который по
пульсу реквеста находит соответствующий ~Pulse Slot~ и ~Slot Machine~
внутри него и там уже создает ~Slot~ и ~SM~, которая обслуживает
~Request~.

[[file:../img/conveyor-pic001.png]]

* Погружаясь в SM

Состояния конечного автомата представляется методами класса, которые
получают контекст исполнения и возвращают ~stateUpdate~, по которому
состояние SM будет переключено. Контекст для этого имеет метод, который
создаст операцию, которая после выхода из метода гарантирует переключение
в то состояние на которое указывает возвращаемое значение.

Гарантируется, что пока происходит выполнение метода, никто не получит
доступ к этому экземпляру SM.

** Асинхронный адаптер

Требуется, чтобы метод был быстрый, не выполнял ожидания, все
взаимодействие с внешним миром должно быть асинхронным, через
~адаптер~. Для этого нужно сделать запрос и указать в нем, что должно
быть сделано на вызываемой стороне и что должно быть прислано
обратно. Также нужно указать коллбэк, который получает специальный
контеккст, в котором есть операция ~WakeUp~, которая пошлет сигнал
побудки, о котором дальше.

Этот запрос не будет выполнен, а будет отложен до момента выхода из
текущего метода-состояния, чтобы не нарушать гарантий
асинхронности. Поэтому чтобы дождаться возвращения результата запроса
следует писать

#+BEGIN_SRC go
  return ctx.Sleep().ThenJump(s.nextStep) #+END_SRC

Sleep() - это builder, который билдит предикат-операцию, которая говорит:
"после выхода из текущего состояния прекратить выполнение SM, но не
уничтожать ее, и если придет сигнал побудки (который мы ожидаем получить
из коллбека на асинхронный вызов) то тогда изменить состояние на
~nextStep~.

Если асинхронных вызовов будет несколько, то нужно самостоятельно
разобраться от какого колбэка мы получили сигнал, который нас
разбудил. SM ведет учет асинхронных вызовов, поэтому всегда можно узнать
сколько асинхронных вызовов еще не завершились, чтобы обработать все.

- Может ли одна SM пробудить другую по ~WakeUp~ сигналу?
- Нет, без ~barge in~-метода (о нем далее). Но если потребуется можно
  что-нибудь придумать решение для этого.

У каждой SM есть метод Init, принимающий InitContext для которого
гарантируется выполнение только один раз и который не имеет права
выполнять исходящие операции (Wait или внешний запрос).

Другие методы принимают ExecutionContext.

Немного кишков: вызов к адаптеру - это замыкание, которое уезжает в
очередь адаптера, который обслуживает какой-то внешний сервис. Т.е. весь
код, который будет выполнен содержится в этом замыкании и будет выполнен
в контексте сервиса. Это замыкание должно вернуть другое замыкание,
которое будет возвращено и синхронизированно с состоянием SM.

~Request~ приходит как сетевой запрос, который обрабатывается сетевым
обработчиком. Потом обработчик вызывает ~SM~, которая вызывает ~адаптер~
чтобы асинхронно отправлять, например, сообщения по сети.


** ~Slot Id~ и ~Slot Link~

Есть ~Slot Id~ - числовой идентификатор для ~Slot~ уникальный в пределах
~Slot Machine~. Большие массивы ~Slot~-ов получают ~Slot Id~ в процессе
аллокации чтобы снизить нагрузку на Garbage Collector, и когда ~Slot~
переиспользуется - он получает другой ~Slot Id~.

Поэтому существует ~Slot Link~, который внутри держит указатель на ~Slot~
и ~Slot Id~, который был. Поэтому асинхронный коллбэк корректно
обработает ситуацию обращения по ~Slot Link~ который был переиспользован,
(например был остановлен)

~Slot~ может хранить стек ~SM~. Находясь в одной ~SM~ можно вызвать
вложенную ~SM~, которая будет работать на том же слоте. Когда вложенная
SM остановится произойдет возврат.

** Step

~Slot~ хранит в себе ~Step~ - это счетчик выполненных шагов он
пригождается для
- отладки
- чтобы различить выводы одной и той же операции. Логгинг может нарушать
  порядок (поскольку асинхронщина), поэтому чтобы связать момент
  выполнения операции с конкретным шагом имеет смысл указывать номер шага
- для контроля асинхронных операций, когда можно послать вызов вида "мне
  нужен ответ, но если ожидая ответ я сделал шаг, то ответ уже не нужен)
  То же для ~barge in~ о которых далее.

** Migrate

~Slot~ имеет операцию ~Migrate~, которая нужна для работы со сменой
~Pulse~. Определяя метод состояния ~Init~ можно указать, что если
произойдет миграция, то должен быть вызван вот этот обработчик. Если
приходит изменение ~Pulse~, то все ~Slot~-ы, независимо от того в каких
состояниях находятся их SM, должны вызвать обработчик, который должен
сказать:
- оставить ~SM~ в том же состоянии
- перевести ~SM~ в другое состояние
- остановить
- сделать что-либо еще

Есть нетривиальность в том, что случается, когда смена пульса приходит
при незавешенных внешних асинхронных вызовах. Это как-то связано с
делегацией [TODO:gmm] - Узнать подробнее про делегацию. Посмотреть в
конфле Delegation Tokens
https://insolar.atlassian.net/wiki/spaces/DEV/pages/1011614443/Core+v2+-+Delegation+Tokens


Также нужны детали про ситуацию, когда выполнятся вложенная ~SM~ и в этот
момент происходит миграция. В оригинальном видео не совсем понятно и
местами проблема со звуком.

** Logging

Логгирование внутри асихронной SM делается через методы
контекста. Снаружи можно повесить слушатель, который получит лог.

** Sync object

Ограничение - на один слот может быть ~accuire~ только один объект
синхронизации.

~accuire~ возвращает один из 3 вариантов
- passed - можно распряжаться тем что защищает объект синхронизации
- impossible - например, объект не существует
- not passed - запрос поставлен в очередь, когда защищаемое будет
  освобождено, автоматически перейдет в accuired и когда вы в следующий
  раз проверите - будет passed. Это для fairness.

Этот единственный объект синхронизации может поддерживать вложенные
accuire - пример: [TODO:gmm] описать иерарахичный семафор с возможностью
частичного отпуска родителя. Зачем он (кейсы)

** Detached SM

(в этом разделе описана пока не реализованная функциональность)

Если SM в одном из слотов застряла ([TODO:gmm] Как такое может произойти?
Превышение латентности ) и в этот момент произошла миграция, то этот слот
может быть передан отдельному потоку с признаком ~detached~. И когда
пользовательский метод будет завершен, будет возврат в системный код,
который увидит, что в процессе исполнения ~Slot~ был переведен в
состояние ~detached~ и это значит невозможность синхронизации с очередями
~Slot Machine~ напрямую. Тогда detached slot кладет операцию завершения
своего исполнения в очередь синхронизации со ~Slot Machine~ и когда эта
операция будет вынута из очереди ~Slot Machine~ синхронизует detached
slot обратно в себя и после этого будут вызваны все асинхронные операции,
которые ожидали.

** InterSharing SM

Взаимодействие между ~SM~-ами

Допустим, что у нас есть две ~SM~:
- ~SM_1~
- ~SM_2~

и ~SM_2~ хочет расшарить какие-то данные для ~SM_1~. Для этого ~SM_2~
имееет какую-то структуру данных.

~SM_2~ на шаге инициализации вызывает метод ~ctx.Share(..)~ в котором
сообщает, какую ссылку хочет сделать разделяемой. Эта функция возвращает
~SharedLink~. Его можно _как_значение_ передать в другую SM, но если
исходная SM будет уничтожена, то реализация ~SharedLink~ позволяет
разделяемым данным продолжить существовать независимо от умершей SM
(механизм ленивого связывания)

Есть также операция ~ctx.Publish(key, sharedLink)~, которая позволяет
опубликовать разделяемую структуру под некоторым ключом в hashmap который
определен в пределах ~Slot-Machine~. Для того чтобы публиковать в более
широкой области видимости есть ~ctx.GlobalPublish(...)~

После публикации, которую выполнила ~SM_2~, на стороне ~SM_1~ надо
сделать ~ctx.GetPublish(key)~, который вернет ~SharedLink~, с которым
нужно будет сделать ~TryUse~.

~TryUse~ работает всегда, если не возникает описанной в разделе выше
ситуации с detached или если вторая SM обслуживается другой ~Slot
Machine~. В таких случаях, TryUse как объект синхронизации возвращает три
признака:
- passed - был получен доступ к структуре и на ней было выполнение
  замыкание, которое было передано
- not passed - линк действителен, но объект занят (что нужно сделать
  дальше? - попробовать позже)
- impossible - SharedLink недействителен либо что-то еще пошло не так.

~TryUse~ гарантированно исполняется в режиме исключительного доступа,
если она запустилась. Это обеспечивается путем встраивания выполнения
замыкания _перед_ началом исполнения следующего метода состояния SM.

При использовании ~ctx.Share~ можно установить некоторые флаги. Один из
них позволяет разбудить SM, которая шарит данные, после использования
~TryUse~. В этом случае ~WakeUp~ посылается при выходе из ~TryUse~,
т.к. SM могут быть несвязаны.

** Barge In

Если хочется ~Message Passing~ между SM, то есть операци ~barge
in~. Любая SM может создать ~barge in~-метод, который гарантирует:
- его можно вызвать где угодно (не обязательно из другой SM)
- ему можно передать нетипизированный интерфейс
- он будет вызван на SM после синхронизации и переданный коллбэк будет
  исполнен в контексте SM которая его создала

~barge in~ возвращает коллбэк, который надо вызвать и тогда он выполнит
все необходимое чтобы обеспечить синхронизацию и выполнить переданный
колбэк в нужном контексте.
