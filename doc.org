#+STARTUP: showall indent hidestars

* Disclaimer

Этот документ создан как набор заметок, которые могут помочь (а могут и
помешать) разобраться в основных концепциях проекта Insolar.

Он может содержать фактические ошибки, неточности и даже прямую ложь в
отношении технических концепций, намерений разработчиков, сроков
реализации и сценариев использования. Используйте на свой страх и риск.

Я выкладываю его в свой частный репозиторий для целей совместного
редактирования, чтобы любое заинтересованное лицо могло вносить свои
уточнения и исправлять ошибки.

Все написанное может не совпадать с позицией компании Insolar и является
частным мнением (или заблуждением) автора и/или контрибьюторов

* Overview
** Structure

Из чего состоит Insolar - это список концепций, каждую из которых нужно
рассмотреть.

- Platform Core
  - Network
    - Infrastructure Layer
    - Nodes (with Roles)
    - Pulses
    - Consensus (Optimized BFT)
  - Ledger
    - LightMaterial
    - HeavyMaterial
    - Lifelines / sidelines - Последовательности записей, представляющих
      состояния объектов, которые создаются умными контрактами
    - jets / jet drops - логические единицы хранения, сформированные из lifelines
    - short/long term storage (for jets)
  - VM
  - Contracts
  - Request
  - Platform API
    - Smart Contracts API
    - Business Logic API
    - Observer API
  - Observer
- Business Foundations
  - Domains (supercontract)
    - Domain Rules
  - Toolkuts
- Applications
- External Services

** Принципы

- Everything is SmartContract
- One Executor - Many Validators
- Dynamic consensus: separation of network (nodes) and business
  (contracts) consensuses
- Use different blockchain styles to fit for purpose: one object-one
  chain for object’s lifeline and sidelines, sharded chains for block
  building, block-based chains for storage units
- Different roles (players) in the Insolar Ecosystem: resource providers,
  application developers, application consumers, Insolar
  Foundation. Different incentives & staking & liabilities

* С чего начать объяснять
** С кейсов
*** CANCEL Delivery

~Клиент~ хочет доставить груз ~Получателю~. Для этого ~Клиент~ обращатся
к ~Посреднику~, который аггрегирует предложения от ~Перевозчиков~ и
предоставляет их ~Клиенту~.

~Клиент~ выбирает предложение (или отказывается от выбора - тогда на этом
все заканчивается) и заключает сделку. Теперь у ~Перевозчика~ есть
обязательство выполнить условия сделки: доставить ~Груз~ ~Получателю~.

Отсюда возможны развилки
- (happy-case) ~Получатель~ подтвержает получение ~Груза~. Стороны
  получают свои fees.
- ~Клиент~ отказывается от сделки. Тут могут быть какие-то штрафы
- ~Получатель~ недоволен исполнением сделки. ~Груз~ поврежден или не
  доставлен - как тут происходит решение спора?
- Истек тайм-аут. Происходит действие по умолчанию (груз доставлен скорее
  всего)

[COMMENT:gmm] - Кирила сказал слишком сложно, начать с простого
пинг-понга

*** PinPong


*** Transfer

Инициатором перевода денег является пользователь. Чтобы сделать перевод
он обращается к кошельку (~Wallet~), который является веб или мобильным
приложением.

Чтобы сделать перевод нужно:
- PrivKey
- Addr From
- Addr To

Wallet обращается к платформе через API, это называется ~Request~? На
самом деле он должен обратиться к одной из ~Node~ с ролью
~Virtual~. Тогда как он их получает, обновляет и т п?

~Node~ записывает ~Request~ куда?

** С обсервера и платформы (набора нод)
*** Collector
*** DB
*** API
** Дальше можно про роли нод (хранение и исполнение)

В данный момент в майнете может быть только один Heavy. Остальных сколько
угодно, но у нас пока по пять

Статические роли:
- Virtual (SmartContract Executor)
- LM
- HS
- Pulse

Динамические роли
- Executor
- Validator

По insolar-addr вычисляется Virtual Executor (VE) выбираемый из
ActiveList (динамический). ActiveList зависит от пульса - он формируется
на каждoм пульсе.

Пульс рассылается всем соседям

Отсюда мы переходим к объяснению консенсуса, но сначала:

** What is insolar-addr
** What is pulse

10 second таймслоты

На каждом пульсе:
- отправляется энтропия

*** Смена пульса

Все сложно

Jet-drops

** Consensus

4 фазы

** Discovery

На сетевом уровне

Список захардкожен в коде ноды

Как происходит добавление узлов - через дискавери
Как происходит удаление нод - она перестает отвечать на пульс или
убивается за злонамеренное поведение (еще возможны сценарии)

** Jet

Пусть у нас есть пространство контрактов 2^64 адресов
Если LME видит что данных для сохранения слишком много, то мы делим эти
данные пополам - это Jet.

** Доступ к данным
** Реквест

2 способа сформировать реквест

- из внешнего апи - запрос к кошельку
- запрос на перевод - от одной ноды к другой во время исполнения
  контракта

Реквесты сейвятся, и выполняются. Если реквест не выполнился, то его
довыполнят при этом порядок гарантируется

Транзакционный механизм

** Смартконтракт

это Go-класс, в котором есть поля, и эти поля хранятся на блокчейне как
связный список состояний - его вершина - текущее состояние

** Механизм валидации

сейчас нет.

** Конвейр (1)

Генерация документации в плантУМЛ с возможным анализом стейт-машин
Предложить технологию генерации доков

ну и соотв надо будет в этом разобраться и в первую очередь подумать, как
работать с документированием, чтобы большая часть описания оставалась в
коде

на уровне деклараций
и не надо было руками дублировать
а в идеале - если ещё можно будет анализировать структуру кода state
machine's и по нему рисовать PlantUml представления

как до кода доберёшься - расскажу суть происходящего в этом куске, и на
кой чёрт он нужен

** Филаменты

Объекты которые хранятся в JеtDrop

* Как запускается нода

#+BEGIN_SRC sh
  + export INSOLAR_LOG_FORMATTER=
  + INSOLAR_LOG_FORMATTER=
  + export INSOLAR_LOG_LEVEL=debug
  + INSOLAR_LOG_LEVEL=debug
  discovery+other nodes: 5+0
  check_working_dir() starts ...
  check_working_dir() end.
  bootstrap start
  prepare() starts ...
  stop_listening(): starts ...
  stop_listening(): stop insgorund
  grep: .artifacts/launchnet/bootstrap.yaml: Нет такого файла или каталога
  grep: .artifacts/launchnet/keeperd.yaml: Нет такого файла или каталога
  killing process using port '58090'
  stop_listening() end.
  clear_dirs() starts ...
  + rm -rfv .artifacts/launchnet/discoverynodes/
  удален каталог '.artifacts/launchnet/discoverynodes/certs'
  удален каталог '.artifacts/launchnet/discoverynodes/'
  + rm -rfv .artifacts/launchnet/logs/
  удален каталог '.artifacts/launchnet/logs/insgorund'
  удален каталог '.artifacts/launchnet/logs/discoverynodes/4'
  удален каталог '.artifacts/launchnet/logs/discoverynodes/2'
  удален каталог '.artifacts/launchnet/logs/discoverynodes/5'
  удален каталог '.artifacts/launchnet/logs/discoverynodes/1'
  удален каталог '.artifacts/launchnet/logs/discoverynodes/3'
  удален каталог '.artifacts/launchnet/logs/discoverynodes'
  удален каталог '.artifacts/launchnet/logs/'
  + rm -rfv .artifacts/launchnet/contracts
  + rm -rfv .artifacts/launchnet/logs/discoverynodes/1
  + rm -rfv .artifacts/launchnet/logs/discoverynodes/2
  + rm -rfv .artifacts/launchnet/logs/discoverynodes/3
  + rm -rfv .artifacts/launchnet/logs/discoverynodes/4
  + rm -rfv .artifacts/launchnet/logs/discoverynodes/5
  create_required_dirs() starts ...
  + mkdir -p .artifacts/launchnet/discoverynodes/certs
  + mkdir -p .artifacts/launchnet/configs/
  + mkdir -p .artifacts/launchnet/logs/insgorund/
  + touch .artifacts/launchnet/configs/insgorund_ports.txt
  + mkdir -p .artifacts/launchnet/logs/discoverynodes/1
  + mkdir -p .artifacts/launchnet/logs/discoverynodes/2
  + mkdir -p .artifacts/launchnet/logs/discoverynodes/3
  + mkdir -p .artifacts/launchnet/logs/discoverynodes/4
  + mkdir -p .artifacts/launchnet/logs/discoverynodes/5
  create_required_dirs() end.
  prepare() end.
  build binaries
  + export BUILD_TAGS
  + make build
  mkdir -p bin
  go build -o bin/insolard -tags "debug functest" -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" cmd/insolard/*.go
  go build -o bin/insolar -tags "debug functest" -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" application/cmd/insolar/*.go
  go build -o bin/insgocc -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" application/cmd/insgocc/*.go
  go build -o bin/pulsard -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" cmd/pulsard/*.go
  go build -o bin/testpulsard -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" cmd/testpulsard/*.go
  CGO_ENABLED=1 go build -o bin/insgorund -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" cmd/insgorund/*.go
  go build -o bin/healthcheck -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" cmd/healthcheck/*.go
  go build -o bin/benchmark -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" application/cmd/benchmark/*.go
  go build -o bin/apirequester -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" cmd/apirequester/*.go
  go build -o bin/pulsewatcher -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" cmd/pulsewatcher/*.go
  go build -o bin/backupmanager -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" cmd/backupmanager/*.go
  go build -o bin/keeperd -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" cmd/keeperd/*.go
  go build -o bin/heavy-badger ./cmd/heavy-badger/
  generate pulsar keys: .artifacts/launchnet/configs/pulsar_keys.json
  generate members keys in dir: .artifacts/launchnet/configs/
  generate configs
  + go run -mod=vendor scripts/generate_insolar_configs.go -p .artifacts/launchnet/configs/insgorund_ports.txt
  generate_insolar_configs.go: creates dir .artifacts/launchnet
  generate_insolar_configs.go: write to file .artifacts/launchnet/bootstrap.yaml
  generate_insolar_configs.go: write to file .artifacts/launchnet/prometheus.yaml
  generate_insolar_configs.go: writeInsolardConfigs...
  generate_insolar_configs.go: creates dir .artifacts/launchnet/discoverynodes/1
  generate_insolar_configs.go: write to file .artifacts/launchnet/discoverynodes/1/insolard.yaml
  generate_insolar_configs.go: creates dir .artifacts/launchnet/discoverynodes/2
  generate_insolar_configs.go: write to file .artifacts/launchnet/discoverynodes/2/insolard.yaml
  generate_insolar_configs.go: creates dir .artifacts/launchnet/discoverynodes/3
  generate_insolar_configs.go: write to file .artifacts/launchnet/discoverynodes/3/insolard.yaml
  generate_insolar_configs.go: creates dir .artifacts/launchnet/discoverynodes/4
  generate_insolar_configs.go: write to file .artifacts/launchnet/discoverynodes/4/insolard.yaml
  generate_insolar_configs.go: creates dir .artifacts/launchnet/discoverynodes/5
  generate_insolar_configs.go: write to file .artifacts/launchnet/discoverynodes/5/insolard.yaml
  generate_insolar_configs.go: writeInsolardConfigs...
  generate_insolar_configs.go: write to file .artifacts/launchnet/configs/insgorund_ports.txt
  generate_insolar_configs.go: write to file .artifacts/launchnet/pulsar.yaml
  generate_insolar_configs.go: write to file .artifacts/launchnet/keeperd.yaml
  generate_insolar_configs.go: creates dir .artifacts/launchnet
  generate_insolar_configs.go: write to file .artifacts/launchnet/pulsewatcher.yaml
  generate migration addresses: .artifacts/launchnet/configs/migration_addresses.json
  start bootstrap ...
  + bin/insolar bootstrap --config=.artifacts/launchnet/bootstrap.yaml --certificates-out-dir=.artifacts/launchnet/discoverynodes/certs
  + GENESIS_EXIT_CODE=0
  bootstrap log: .artifacts/launchnet/logs/bootstrap.log
  bootstrap is done
  copy_certs() starts ...
  + cp -v .artifacts/launchnet/discoverynodes/certs/discovery_cert_1.json .artifacts/launchnet/discoverynodes/1/cert.json
  '.artifacts/launchnet/discoverynodes/certs/discovery_cert_1.json' -> '.artifacts/launchnet/discoverynodes/1/cert.json'
  + cp -v .artifacts/launchnet/discoverynodes/certs/discovery_cert_2.json .artifacts/launchnet/discoverynodes/2/cert.json
  '.artifacts/launchnet/discoverynodes/certs/discovery_cert_2.json' -> '.artifacts/launchnet/discoverynodes/2/cert.json'
  + cp -v .artifacts/launchnet/discoverynodes/certs/discovery_cert_3.json .artifacts/launchnet/discoverynodes/3/cert.json
  '.artifacts/launchnet/discoverynodes/certs/discovery_cert_3.json' -> '.artifacts/launchnet/discoverynodes/3/cert.json'
  + cp -v .artifacts/launchnet/discoverynodes/certs/discovery_cert_4.json .artifacts/launchnet/discoverynodes/4/cert.json
  '.artifacts/launchnet/discoverynodes/certs/discovery_cert_4.json' -> '.artifacts/launchnet/discoverynodes/4/cert.json'
  + cp -v .artifacts/launchnet/discoverynodes/certs/discovery_cert_5.json .artifacts/launchnet/discoverynodes/5/cert.json
  '.artifacts/launchnet/discoverynodes/certs/discovery_cert_5.json' -> '.artifacts/launchnet/discoverynodes/5/cert.json'
  copy_certs() end.
  kill all processes: insgorund, insolard, pulsard
  insgorund: процесс не найден
  insolard: процесс не найден
  pulsard: процесс не найден
  start pulsar ...
     log: .artifacts/launchnet/logs/pulsar_output.log
  + mkdir -p .artifacts/launchnet/pulsar_data
  pulsar log: .artifacts/launchnet/logs/pulsar_output.log
  + bin/pulsard -c .artifacts/launchnet/pulsar.yaml
  launch_keeperd() starts ...
  launch_keeperd() end.
  start insgorund ...
  start heavy node
  heavy node started in background
  log: .artifacts/launchnet/logs/discoverynodes/1/output.log
  start discovery nodes ...
  + tee .artifacts/launchnet/logs/discoverynodes/1/output.log
  + bin/insolard --config .artifacts/launchnet/discoverynodes/1/insolard.yaml --heavy-genesis .artifacts/launchnet/configs/heavy_genesis.json
  [1]   Запущен          ${PULSARD} -c ${PULSAR_CONFIG} &> ${LAUNCHNET_LOGS_DIR}pulsar_output.log &
  [2]   Запущен          ${KEEPERD} --config=${KEEPERD_CONFIG} &> ${KEEPERD_LOG} &
  [3]   Запущен          ${INSGORUND} -l ${host}:${listen_port} --rpc ${host}:${rpc_port} --log-level=${GORUND_LOG_LEVEL} --metrics :${metrics_port} &> ${INSGORUND_LOGS}${rpc_port}.log &
  [4]-  Запущен          ${INSGORUND} -l ${host}:${listen_port} --rpc ${host}:${rpc_port} --log-level=${GORUND_LOG_LEVEL} --metrics :${metrics_port} &> ${INSGORUND_LOGS}${rpc_port}.log &
  [5]+  Запущен          $INSOLARD --config ${DISCOVERY_NODES_DATA}1/insolard.yaml --heavy-genesis ${HEAVY_GENESIS_CONFIG_FILE} 2>&1 | ${LOGROTATOR} ${DISCOVERY_NODE_LOGS}1/output.log > /dev/null &
  someone left the network
  discovery node 2 started in background
  log: .artifacts/launchnet/logs/discoverynodes/2/output.log
  + bin/insolard --config .artifacts/launchnet/discoverynodes/2/insolard.yaml
  + tee .artifacts/launchnet/logs/discoverynodes/2/output.log
  discovery node 3 started in background
  log: .artifacts/launchnet/logs/discoverynodes/3/output.log
  + tee .artifacts/launchnet/logs/discoverynodes/3/output.log
  discovery node 4 started in background
  log: .artifacts/launchnet/logs/discoverynodes/4/output.log
  + bin/insolard --config .artifacts/launchnet/discoverynodes/3/insolard.yaml
  discovery node 5 started in background
  log: .artifacts/launchnet/logs/discoverynodes/5/output.log
  + tee .artifacts/launchnet/logs/discoverynodes/4/output.log
  discovery nodes started ...
  starting pulse watcher...
  bin/pulsewatcher -c .artifacts/launchnet/pulsewatcher.yaml
  + bin/insolard --config .artifacts/launchnet/discoverynodes/4/insolard.yaml
  + tee .artifacts/launchnet/logs/discoverynodes/5/output.log
  + bin/insolard --config .artifacts/launchnet/discoverynodes/5/insolard.yaml

     URL   |        STATE         |       ID       | NETWORK PULSE |     PULSE     |    ACTIVE    | WORKING |      ROLE       |    TIMESTAMP    | UPTIME | ERROR
  +--------+----------------------+----------------+---------------+---------------+--------------+---------+-----------------+-----------------+--------+-------+
    :19001 | CompleteNetworkState |  😈 992962443  |      33020724 |      33020724 | 5 ⚽🏀😆😀😈 |       5 | Heavy           | 13:13:17.378508 | 49m30s |
    :19002 | CompleteNetworkState |  ⚽ 3309296920 |      33020724 |      33020724 | 5 ⚽🏀😆😀😈 |       5 | Virtual         | 13:13:17.378548 | 49m30s |
    :19003 | CompleteNetworkState |  😀 114004987  |      33020724 |      33020724 | 5 ⚽🏀😆😀😈 |       5 | Light           | 13:13:17.378511 | 49m30s |
    :19004 | CompleteNetworkState |  🏀 1505477843 |      33020724 |      33020724 | 5 ⚽🏀😆😀😈 |       5 | Virtual         | 13:13:17.378509 | 49m30s |
    :19005 | CompleteNetworkState |  😆 1846903875 |      33020724 |      33020724 | 5 ⚽🏀😆😀😈 |       5 | Light           | 13:13:17.378508 | 49m30s |
  +--------+----------------------+----------------+---------------+---------------+--------------+---------+-----------------+-----------------+--------+-------+
                                                                     INSOLAR STATE |    READY     |  TIME   | 13:13:17.379047 | INSOLAR UPTIME  | 49M30S |
                                                                   +---------------+--------------+---------+-----------------+-----------------+--------+-------+
  ^Cstop_listening(): starts ...
  stop_listening(): stop insgorund
  scripts/insolard/launchnet.sh: строка 126: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 117: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 127: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 117: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 126: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 117: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 127: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 117: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 132: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 117: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 136: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 117: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 137: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 117: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing process using port '58090'
  scripts/insolard/launchnet.sh: строка 97: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 95: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing process using port '58090'
  scripts/insolard/launchnet.sh: строка 97: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 95: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing process using port '33305'
  scripts/insolard/launchnet.sh: строка 97: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 95: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing pid 7805 at Пт янв 17 13:13:18 MSK 2020
  scripts/insolard/launchnet.sh: строка 98: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing process using port '33306'
  scripts/insolard/launchnet.sh: строка 97: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 95: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing pid 7834 at Пт янв 17 13:13:18 MSK 2020
  scripts/insolard/launchnet.sh: строка 98: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing process using port '33327'
  scripts/insolard/launchnet.sh: строка 97: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 95: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing pid 7824 at Пт янв 17 13:13:18 MSK 2020
  scripts/insolard/launchnet.sh: строка 98: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing process using port '33328'
  scripts/insolard/launchnet.sh: строка 97: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 95: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing pid 7838 at Пт янв 17 13:13:18 MSK 2020
  scripts/insolard/launchnet.sh: строка 98: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing process using port '7805'
  scripts/insolard/launchnet.sh: строка 97: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 95: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing process using port '7824'
  scripts/insolard/launchnet.sh: строка 97: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 95: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  stop_listening() end.
  kill all processes: insgorund, insolard, pulsard
  insgorund: процесс не найден
  scripts/insolard/launchnet.sh: строка 107: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 107: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 107: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  FINISHING ...
  stop_listening(): starts ...
  stop_listening(): stop insgorund
  [1]   Завершён        ${PULSARD} -c ${PULSAR_CONFIG} &> ${LAUNCHNET_LOGS_DIR}pulsar_output.log
  [3]   Завершён        ${INSGORUND} -l ${host}:${listen_port} --rpc ${host}:${rpc_port} --log-level=${GORUND_LOG_LEVEL} --metrics :${metrics_port} &> ${INSGORUND_LOGS}${rpc_port}.log
  [4]   Завершён        ${INSGORUND} -l ${host}:${listen_port} --rpc ${host}:${rpc_port} --log-level=${GORUND_LOG_LEVEL} --metrics :${metrics_port} &> ${INSGORUND_LOGS}${rpc_port}.log
  [6]   Запущен          $INSOLARD --config ${DISCOVERY_NODES_DATA}${i}/insolard.yaml 2>&1 | ${LOGROTATOR} ${DISCOVERY_NODE_LOGS}${i}/output.log > /dev/null &
  [7]   Завершён        $INSOLARD --config ${DISCOVERY_NODES_DATA}${i}/insolard.yaml 2>&1 | ${LOGROTATOR} ${DISCOVERY_NODE_LOGS}${i}/output.log > /dev/null
  [8]-  Запущен          $INSOLARD --config ${DISCOVERY_NODES_DATA}${i}/insolard.yaml 2>&1 | ${LOGROTATOR} ${DISCOVERY_NODE_LOGS}${i}/output.log > /dev/null &
  [9]+  Завершён        $INSOLARD --config ${DISCOVERY_NODES_DATA}${i}/insolard.yaml 2>&1 | ${LOGROTATOR} ${DISCOVERY_NODE_LOGS}${i}/output.log > /dev/null
  someone left the network
  someone left the network
  someone left the network
  someone left the network
  someone left the network
  someone left the network
  someone left the network
  someone left the network
  killing process using port '58090'
  someone left the network
  killing process using port '58090'
  someone left the network
  killing process using port '33305'
  someone left the network
  killing process using port '33306'
  someone left the network
  killing pid 7834 at Пт янв 17 13:13:18 MSK 2020
  someone left the network
  killing process using port '33327'
  [5]   Завершён        $INSOLARD --config ${DISCOVERY_NODES_DATA}1/insolard.yaml --heavy-genesis ${HEAVY_GENESIS_CONFIG_FILE} 2>&1 | ${LOGROTATOR} ${DISCOVERY_NODE_LOGS}1/output.log > /dev/null
  someone left the network
  someone left the network
  someone left the network
  killing process using port '33328'
  someone left the network
  killing pid 7838 at Пт янв 17 13:13:18 MSK 2020
  someone left the network
  killing process using port '7805'
  someone left the network
  killing process using port '7824'
  someone left the network
  killing process using port '58090'
  someone left the network
  killing process using port '33305'
  someone left the network
  killing process using port '33306'
  someone left the network
  killing pid 7834 at Пт янв 17 13:13:18 MSK 2020
  someone left the network
  killing process using port '33327'
  someone left the network
  killing process using port '33328'
  someone left the network
  killing pid 7838 at Пт янв 17 13:13:18 MSK 2020
  someone left the network
  stop_listening() end.
  kill all processes: insgorund, insolard, pulsard
  insgorund: процесс не найден
  someone left the network
  someone left the network
  pulsard: процесс не найден
  someone left the network
#+END_SRC
* Мои задачи
** Собрать документацию используя GoDoc
** Собрать PlantUML диаграммы используя семантический анализ кода
* Что делать
** DONE Настроить GoModules в GoLand

File->Settings->GoModules->EnableGoModules(vgo)Integration:=true

** DONE Настроить go-mode в emacs
** Запускать и анализировать тесты

Запускать тесты можно прямо из GoLand но надо разобраться как они
работают из CLI

** Добавить логгер

Добавить адаптер в ~/conveyer/smashine/main.go~.

и перезагрузить среду(?)

получается следующий diff для go.mod (этот файл в .gitignore):

#+BEGIN_SRC
  diff --git a/ledger-core/v2/go.mod b/ledger-core/v2/go.mod
  index 9754299..ab17280 100644
  --- a/ledger-core/v2/go.mod
  +++ b/ledger-core/v2/go.mod
  @@ -4,11 +4,8 @@ go 1.12

   require (
          contrib.go.opencensus.io/exporter/prometheus v0.1.0
  -       github.com/AndreasBriese/bbloom v0.0.0-20190825152654-46b345b51c96 // indirect
          github.com/ThreeDotsLabs/watermill v1.0.2
  -       github.com/beorn7/perks v1.0.1 // indirect
          github.com/cheggaaa/pb/v3 v3.0.1
  -       github.com/codahale/hdrhistogram v0.0.0-20161010025455-3a0bb77429bd // indirect
          github.com/dgraph-io/badger v1.6.0-rc1.0.20191024172150-efb9d9d15d7f
          github.com/dustin/go-humanize v1.0.0
          github.com/fortytw2/leaktest v1.3.0
  @@ -23,36 +20,24 @@ require (
          github.com/grpc-ecosystem/grpc-gateway v1.9.6
          github.com/hashicorp/golang-lru v0.5.3
          github.com/insolar/component-manager v0.2.1-0.20191028200619-751a91771d2f
  -       github.com/insolar/go-actors v0.0.0-20190805151516-2fcc7bfc8ff9 // indirect
  +       github.com/insolar/insolar v1.3.0 // indirect
          github.com/insolar/rpc v1.2.2-0.20190812143745-c27e1d218f1f
          github.com/insolar/x-crypto v0.0.0-20191031140942-75fab8a325f6
          github.com/jbenet/go-base58 v0.0.0-20150317085156-6237cf65f3a6
  -       github.com/kardianos/osext v0.0.0-20190222173326-2bc1f35cddc0 // indirect
  -       github.com/magiconair/properties v1.8.1 // indirect
  -       github.com/mattn/go-colorable v0.1.4 // indirect
  -       github.com/mattn/go-isatty v0.0.9 // indirect
          github.com/olekukonko/tablewriter v0.0.1
          github.com/onrik/gomerkle v1.0.0
          github.com/opentracing/opentracing-go v1.1.0
  -       github.com/pelletier/go-toml v1.4.0 // indirect
          github.com/pkg/errors v0.8.1
          github.com/prometheus/client_golang v1.0.0
  -       github.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4 // indirect
  -       github.com/prometheus/common v0.6.0 // indirect
  -       github.com/prometheus/procfs v0.0.4 // indirect
          github.com/rs/zerolog v1.15.0
          github.com/satori/go.uuid v1.2.1-0.20181028125025-b2ce2384e17b
  -       github.com/spf13/afero v1.2.2 // indirect
          github.com/spf13/cobra v0.0.5
          github.com/spf13/jwalterweatherman v1.1.0
          github.com/spf13/pflag v1.0.3
          github.com/spf13/viper v1.4.0
          github.com/stretchr/testify v1.4.0
          github.com/tylerb/gls v0.0.0-20150407001822-e606233f194d
  -       github.com/tylerb/is v2.1.4+incompatible // indirect
  -       github.com/uber-go/atomic v1.4.0 // indirect
          github.com/uber/jaeger-client-go v2.19.0+incompatible
  -       github.com/uber/jaeger-lib v2.2.0+incompatible // indirect
          github.com/ugorji/go v1.1.4
          go.opencensus.io v0.22.0
          golang.org/x/crypto v0.0.0-20190820162420-60c769a6c586
  @@ -60,7 +45,6 @@ require (
          golang.org/x/sync v0.0.0-20190423024810-112230192c58
          golang.org/x/sys v0.0.0-20190826190057-c7b8b68b1456
          golang.org/x/tools v0.0.0-20190827205025-b29f5f60c37a
  -       gonum.org/v1/gonum v0.0.0-20191018104224-74cb7b153f2c // indirect
          google.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55
          google.golang.org/grpc v1.21.0
          gopkg.in/yaml.v2 v2.2.7
#+END_SRC

#+BEGIN_SRC go
  sm := smachine.NewSlotMachine(smachine.SlotMachineConfig{
    SlotPageSize:         1000,
    PollingPeriod:        10 * time.Millisecond,
    PollingTruncate:      1 * time.Microsecond,
    BoostNewSlotDuration: 10 * time.Millisecond,
    ScanCountLimit:       scanCountLimit,
    SlotMachineLogger:    nil, // TODO put logger adapter here
  }, signal.NextBroadcast, signal.NextBroadcast, nil)
#+END_SRC

Логгер даст трассу работы

Потом можно добавлять вызов логгера в каждое состояние. Например, в файле
~conveyor/smachine/main/example/example_1.go~ внутри func (s
*StateMachine1) ~State1(ctx smachine.ExecutionContext) smachine.StateUpdate~

** Написать use-case и smachine для него
*** Описание теста конвейера

Окей, что я понял из теста конвейера:

Первым делом мы определяем ~MachineConfig~ с набором параметров,
назначение которых мне пока непонятно.

Потом делаем фабрику, которая представляет собой функцию, которая
возвращающает <функцию стейт-машины>. Эта <функция стейт-машины> принимает
только ~ConstructionContext~, а возвращает экзэмпляр типа ~AppEventSM~,
который содержит несколько полей, назначение которых мне непонятно, и
номер пульса.

Потом мы между делом добавляем в ~MachineConfig~ логгер, непонятно почему
тут, а не когда мы опредяли ~MachineConfig~, впрочем это маловажно

Дальше мы создаем конвеер конструктором ~NewPulseConveyor~, передавая ему
~MachineConfig~, фабрику и еще несколько параметров. При создании
создается слот-машина, внутри которой есть <пул слотов> и <очередь
синхронизации>.

- ~Пул слотов~ содержит массив массивов слотов, названный ~SlotPages~ и я не
понимаю почему, но возможно это станет понятнее если посмотреть как
осуществляются манипуляции со слотами.

- ~Очередь синхронизации~ по-видимому обрабатывает сигналы и события извне,
что дает возможность слот-машине реагировать на них. Надо будет позже
внимательнее рассмотреть это "извне".

Где-то тут исходя из логики должна быть подписка на изменение пульса и
предположительно она происходит через сигналы, которые, по какой-то
причине бывают внешние и внутренние. Они являются полями конвейра и чтобы
с ними глубже разобраться надо смотреть в ~sunckit~. Кажется там много
интересного, потому что они версионируются и броадкастятся.

Еще конвейер содержит т.н. ~PulseDataManager~, там много всего и
непонятно в каких оно отношениях с сигналами.

Энивэй, после создания конвейера создается ~PulsarData~, предположительно
источник распространения пульса. Я представляю это себе как
распространение информации о изменении пульса по графу сети, но, возможно
ошибаюсь.

Потом у конвейера запускается ~Worker~

Дальше тест проверяет отсутствие ошибок на conveyor.CommitPulseChange и
засыпает.

Потом в цикле:
- ~PulsarData~ делает CreateNextPulsarPulse, после чего пульс
  подготавливается (зачем?) и коммитится
- Проверяется отстутствие ошибко при conveyor.AddInput (я пока не понимаю
  что такое Input вообще)
- Есть какой-то неясный кусок кода с GetPublishedGlobalAlias и smachine.ScheduleCallTo

И на этом вроде бы все

*** Описание слот-машины

Итак, сначала мы создаем новый сигнал, а потом слот-машину, передавая ей
конфиг и siginal.NextBroadcast в качестве коллбэков eventCallback и
SignalCallback. В конфиге идут настройки времени поллинга, размер
страницы итп)

Потом мы инжектим в слот-машину зависимости (которые в этом примере не
нужны, понадобятся в конвейере и дальнейшей эксплуатации)

Стейт-машины попадают в слот-машины с помощью метода
~SlotMachine.AddNew~, который принимает:
- контекст
- стейт-машину
- какие-то дефолтные значения
Этот метод добавляет подготавливает новый слот, записывая в него
дефольные значения, а потом через ~SlotMachineSync.AddAsyncUpdate~
по-видимому, добавляет слот в очередь SlotMachineSync.
(см. [[*%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C %D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8 %D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B8
 SlotMachine][Модель синхронизации внутри SlotMachine]])

В любом случае, ~SlotMachine.AddNew~ возвращает ~SlotLink~, который по
сути пара из айдишника и указателя на слот. Возвращаемое значение не
используется. На этом этапе у нас есть ~SlotMashine~ а в ней
~StateMachine1~.

С помощью ~sworker.NewAttachableSimpleSlotWorker~ мы инициализируем
~WorkerFactory~, что как бы намекает, что в будущем SlotWorker будет к
чему-то присоединен. Если посмотреть, то это просто указатель на
~uint32~, завернутый в тип ~AttachableSimpleSlotWorker~. Он записывается
в переменную ~WorkerFactory~, потому что этот пример  использует
примитивную затычку для Worker'а.

Еще мы получаем новый сигнал ~neverSignal~. Он будет передан в
WorkerFactory.AttachTo, видимо потому что она должна принять какой-то
сигнал. Больше он нигде не используется.

Далее идет цикл, который просто упрощенный пример цикла одного Worker`a:
- wakeupSignal := signal.Mark() - по-видимому, там внутри взводится
  сигнал с помощью CAS - уточнить <?>
- ~workerFactory.AttachTo~. Что он делает? По-видимому присоединяет к
  слот-машине функцию, которая принимает ~worker~ и передает его в
  ~SlotMachine.ScanOnce~. Внутри ScanOnce как раз и идет исполнение шагов
  стейт-машины.
  - Поэтому идем глубже и видим, что в ~AttachTo~ создается и
    инициализируется ~SimpleSlotWorker~ а потом на нем вызывается эта
    самая переданная функция
- раз в интервал (1e8/scanCountLimit) происходит консольный вывод - чтобы
  не слишком часто, видимо.
- Если ~nextPollTime~ не кончилось то мы спим, иначе
  ~wakeupSignal.Wait()~, т.е. это ожидание на сигнале
  предположительно. Не понимаю как именно оно работает внутри <?>

*** Модель синхронизации внутри SlotMachine

Есть три типа сигналов:
- signal,
- external event,
- internal event
и два типа отложенных действий
- update
- async
плюс три типа зон контроля (по типу Woroker'а)

[TODO:gmm] - распросить подробнее

*** Как работают SM

те которые влияют на шаг
и те котореые конфигурируют

У нас есть т.н. ~стейт-машина~ (SM), которая представляет собой gо-шный
класс. В этом классе есть методы состояний, которые принимают в качестве
параметра ~...Context~. Когда метод состояния хочет сделать переключение
шага стейт-машины - он возвращает (return) метод этого
контекста. Например, метод ~return ctx.Jump(s.StateX)~ безусловно
переключает стейт-машину ~s~ в состояние ~StateX~.

Каждой стейт-машине соответствует ~слот~. Слот представляет собой все что
необходимо чтобы управлять стейт-машиной - запускать ее на выполнение,
хранить следующее состояние, и.т.п. Слоты содержаться в ~Слот-машине~,
она же ими и управляет (процессит)

~Конвейер~ же управляет множеством слот-машин, с учетом переключения
пульсов.

Для того чтобы SM могли взаимодействовать друг с другом и окружением
существует ~Контексты~ (и не только для этого)
(см. smachine/api_context.go). SM могут публиковать в нем разделяемые
ресурсы и получать к ним конкурентный доступ. При этом нельзя просто
положить в контекст что-то, а потом читать и писать это, т.к. начнутся
гонки. Поэтому, формируя разделяемый ресурс, надо пройти несколько шагов:
- Сначала надо определить ключ, по которому будет опубликован разделяемый
  ресурс. Этот ключ можно определить прямо в структуре SM и
  инициализировать вместе с SM.
- Потом, используя этот ключ и контекст нужно создать разделямый
  объект. Этим занимается ~catalogC.GetOrCreate()~, делая следующее:
  - Разделяемый объект нельзя создать просто так, он должен принадлежать
    какой-то SM.
  - Поэтому сначала надо создать SM (например, дочернюю к текущей) с
    помощью ~ctx.InitChild~, передав ей функцию, которая формирует
    SharedState нужного типа, заполняя её данными. Таким образом эта
    функция замыкает одновременно данные, которыми инициализируется
    SharedState и контекст.
  - После этого вызывается ~catalogC.Get~, ему передается контекст и
    ключ, по которому в контексте производится поиск. Если поиск успешен,
    то возвращается типизированный accessor, который предоставляет
    доступ, в противном случае - panic
    - Поиск осуществляет ~catalogC.TryGet~ - он обращается к контектсту
      по ключу, при этом в дополнение к accessor-у возвращатеся
      bool-значение можно ли использовать этот ассессор. Это определяется
      с помощью ~SharedDataLink.isAssignableTo~, которому передается
      типизированный nil, а он использует эту типизацию чтобы рефлектом
      определить assignable или нет.
  - Теперь accessor можно применить для доступа к ключу, который
    представляет собой типизированную обертку над ~SharedDataLink~,
    внутри которого уже ссылка на нетипизированные данные.
- После этого мы должны сделать ~Prepare~ (конкретной обертки) над нашим
  типизированным ~Accessor-ом~. Это создает метод доступа, который будет
  применять ~SharedDataFunc~ к линку. Prepare возвращает
  ~SharedDataAceessor~
- Потом мы делаем ~SharedDataAccessor.TryUse~, передавая ему
  контекст. Тот возвращает ~SharedAccessReport~, который по сути - код
  возврата, который определяет, удалось ли получить доступ и если нет то
  почему. В зависимости от этого кода возврата мы можем сделать те или
  иные действия.

*** Написать пинг-понг

У меня есть толпа из 100 SM, они хотят играть.

Все SM знают ключ SharedObject-a, в котором происходит формирование пар,
потому что этот ключ в них зашит. Например это ключ "make-pair".

Когда SM стартует (~Start~), она обращается к этому Shared-у, и, если он
еще не создан, создает его, записывая в поле ~FirstPlayer~ свой UID. Для
простоты пусть это будет просто UID=адрес, т.к. мы пока работаем внутри
единственного адресного пространства. Записав себя в ~FirstPlayer~ SM
переходит в состяние ~WaitForSecond~ и ждет на нем, когда поле
~SecondPlayer~ в Shared-e изменится (если перепрыгнуть через следующий
абзац, то можно увидеть что будет дальше)

Если Shared существует, то SM:
- записывает свой UID в поле SecondPlayer
- вычисляет key = (FirstPlayerUID ⊕ SecondPlayerUID) и сохраняет его себе
и переходит в состояние ~WaitForGame~, в котором ожидает, когда появится
опубликованный SharedObject с ключом, который зависит от обоих UID.

Внутри состояния ~WaitForSecond~ когда поле SecondPlayer изменилось, SM
создает SharedObject с ключом (FirstPlayerUID ⊕ SecondPlayerUID) и
"вбрасывает мяч" - т.е. инициализирует поле BallOwner. А потом переходит
в состяние Game (и надо снова перепрыгнуть через след. абзац)

Внутри состояния WaitForGame, когда появился
опубликованный объект с ключом (FirstPlayerUID ⊕ SecondPlayerUID) SM
переходит в состояние Game

Теперь они оба в состянии Game и перекидываются мячиком изменяя поле
Owner, с шансом попасть в состояние GameOver.

Когда это происходит, первый объект, установивший GameOver обнуляет
Owner, а второй (который обнаруживает это) делает UnPublish
SharedObject-а, после чего они оба переходят к поиску нового партнера.

*** Разпарсить пинг-понг

Парсер

#+NAME:
#+BEGIN_SRC go
  ///
  //    Copyright 2019 Insolar Technologies
  //
  //    Licensed under the Apache License, Version 2.0 (the "License");
  //    you may not use this file except in compliance with the License.
  //    You may obtain a copy of the License at
  //
  //        http://www.apache.org/licenses/LICENSE-2.0
  //
  //    Unless required by applicable law or agreed to in writing, software
  //    distributed under the License is distributed on an "AS IS" BASIS,
  //    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  //    See the License for the specific language governing permissions and
  //    limitations under the License.
  ///

  package main

  import (
      "fmt"
      "github.com/insolar/assured-ledger/ledger-core/v2/insolar"

      "github.com/pkg/errors"
      "go/ast"
      "go/parser"
      "go/token"
      "io/ioutil"
      "os"
      "reflect"
      "strings"
  )

  const (
      TemplateDirectory = "templates"

      filename = "src/github.com/insolar/assured-ledger/ledger-core/v2/conveyor/smachine/ping-pong/example/example_3.go"
      mainPkg   = "main"
      errorType = "error"
      MachineTypeGoPlugin
  )

  type ParPair struct {
      Name 	string
      Type 	string
  }

  type SelPair struct {
      Obj 		string
      Fun			string
  }

  const (
      RetTypeCall = "▷"
  )

  type Ret struct {
      Lvl		string
      Str 	string
      Type	string
      Sel		SelPair
      Args    []string
  }

  type FnState struct {
      Name 	string
      Recv    *ParPair
      Pars    []*ParPair
      Rets    []*Ret
  }

  // ParsedFile struct with prepared info we extract from source code
  type ParsedFile struct {
      filename             string
      code                []byte
      fileSet             *token.FileSet
      node                *ast.File
      machineType         insolar.MachineType
      panicIsLogicalError bool

      states       map[string]*FnState

      types        map[string]*ast.TypeSpec
      methods      map[string][]*ast.FuncDecl
      constructors map[string][]*ast.FuncDecl
      contract     string
  }

  func main() {
      pathname:= fmt.Sprintf("%s/%s", os.Getenv("GOPATH"), filename)
      // fmt.Printf("\n:: parsing for::['%s']", pathname)
      // parsed, err := ParseFile(pathname, insolar.MachineTypeGoPlugin)
      // fmt.Printf("\n:: <= err: %s \n:: <=parsed: %s", err, parsed)
      ParseFile(pathname, insolar.MachineTypeGoPlugin)
  }

  // ParseFile parses a file as Go source code of a smart contract
  // and returns it as `ParsedFile`
  func ParseFile(fileName string, machineType insolar.MachineType) (*ParsedFile, error) {
      pf := &ParsedFile{
          filename:        fileName,
          machineType: machineType,
      }
      fmt.Printf("\n:: resource filename: %s", pf.filename)

      sourceCode, err := slurpFile(fileName)
      if err != nil {
          return nil, errors.Wrap(err, "Can't read file")
      }
      pf.code = sourceCode

      pf.fileSet = token.NewFileSet()
      node, err := parser.ParseFile(pf.fileSet, pf.filename, pf.code, parser.ParseComments)
      if err != nil {
          return nil, errors.Wrapf(err, "Can't parse %s", fileName)
      }
      pf.node = node

      ast.Inspect(node, func(n ast.Node) bool {
          fn, ok := n.(*ast.FuncDecl)
          if ok {
              pf.parseMethod(fn)  // TODO: return value
          }
          return true
      })

      return pf, nil
  }

  func (pf *ParsedFile) parseMethod(fn *ast.FuncDecl) {
      // I want to analise only method functions
      for _, fld := range fn.Recv.List {

          // I want analyse only method-functions
          if 1 != len(fld.Names) { // There is method function
              continue
          }

          // I want analyse only exported methods
          if !fn.Name.IsExported() {
              continue
          }

          // Receiver
          recv := &ParPair{
              Name : fld.Names[0].Name,
              Type : fmt.Sprintf("%s", pf.code[fld.Type.Pos()-1:fld.Type.End()-1]),
          }

          // Parameters
          var pars []*ParPair
          for _, par := range fn.Type.Params.List {
              param := &ParPair{ // Receiver
                  Name : par.Names[0].Name,
                  Type : fmt.Sprintf("%s", pf.code[par.Type.Pos()-1:par.Type.End()-1]),
              }
              pars = append(pars, param)
          }

          // I want to analyse only methods, who takes context
          if !isMethodTakesCtx(pars) {
              continue
          }

          // I want to analyze methods which have a `smashine.StateUpdate' result type
          res := fn.Type.Results.List[0].Type
          resSel, ok := res.(*ast.SelectorExpr)
          if !ok || "StateUpdate" != resSel.Sel.Name {
              continue
          }
          resXstr := fmt.Sprintf("%s", pf.code[resSel.X.Pos()-1:resSel.X.End()-1])
          if "smachine" != resXstr {
              continue
          }

          // Find all Return Statements in function content
          var rets = make([]*Ret, 0)
          for _, smth := range fn.Body.List { // ∀ fn.Body.List ← (or RetStmt (Inspect ...))
              retStmt, ok := smth.(*ast.ReturnStmt)
              if ok {
                  // return from top-level statements of function
                  rets = append(rets, collectRets(retStmt, pf.code, "Top")...)
              } else {
                  ast.Inspect(smth, func(in ast.Node) bool {
                      // Find Return Statements
                      retStmt, ok := in.(*ast.ReturnStmt) // ←
                      if ok {
                          // return from deep-level function statememt
                          rets = append(rets, collectRets(retStmt, pf.code, "Deep")...)
                      } else {
                          //fmt.Printf("\nin: %s", reflect.TypeOf(in))
                      }
                      return true
                  })
              }
          }

          state := FnState{
              Name: fn.Name.Name,
              Recv: recv,
              Pars: pars,
              Rets: rets,
          }

          // Debug output
          fmt.Printf("\n\nfn: %s", state.Name) // Function name
          fmt.Printf("\nrecv: %s | %s", state.Recv.Name, state.Recv.Type) // Receiver
          for _, par := range state.Pars { // Parameters
              fmt.Printf("\npar name: %s | type: %s", par.Name, par.Type)
          }
          for _, item := range state.Rets {
              fmt.Printf("\n%s: ['%s']", item.Lvl, item.Str)
              if RetTypeCall == item.Type {
                  fmt.Printf("\n(▷ (@ %s %s))", item.Sel.Obj, item.Sel.Fun)
                  for _, arg := range item.Args {
                      fmt.Printf("\n%s", arg)
                  }
              }
          }
      }
  }

  func collectRets(retStmt *ast.ReturnStmt, code []byte, level string) []*Ret {
      var acc []*Ret
      for _, ret := range retStmt.Results {
          item := &Ret{
              Lvl:	level,
              Str:	fmt.Sprintf("%s",code[ret.Pos()-1:ret.End()-1]),
          }
          for _, retNode := range retStmt.Results {
              retNodeStr := fmt.Sprintf("%s", reflect.TypeOf(retNode))
              switch retNodeStr {
              case "*ast.CallExpr":
                  item.Type = RetTypeCall
                  retCall := retNode.(*ast.CallExpr)
                  retSelStr := fmt.Sprintf("%s", reflect.TypeOf(retCall.Fun))
                  switch retSelStr {
                  case "*ast.SelectorExpr":
                      retSelector := retCall.Fun.(*ast.SelectorExpr)
                      retX, ok := retSelector.X.(*ast.Ident)
                      if ok {
                          item.Sel.Obj = retX.Name
                      } else { // may be not Ident !
                          fmt.Printf("\nERR: UNKNOWN RETSELECTOR %s", reflect.TypeOf(retSelector.X))
                      }
                      item.Sel.Fun = retSelector.Sel.Name
                      // Args
                      accArgs := make([]string, 0)
                      for _, retarg := range retCall.Args {
                          retArgTypeStr := fmt.Sprintf("%s", reflect.TypeOf(retarg))
                          switch retArgTypeStr {
                          case "*ast.SelectorExpr":
                              sel := retarg.(*ast.SelectorExpr)
                              selName := fmt.Sprintf("%s", code[sel.X.Pos()-1:sel.X.End()-1])
                              arg := fmt.Sprintf("    (@ %s %s)", selName, sel.Sel.Name)
                              accArgs = append(accArgs, arg)
                          case "*ast.Ident":
                              idn := retarg.(*ast.Ident)
                              arg := fmt.Sprintf("    %s", idn.Name)
                              accArgs = append(accArgs, arg)
                          default:
                              fmt.Printf("\nERR: UNKNOWN RETARG('%s' of %s)", retarg, reflect.TypeOf(retarg))
                          }
                      }
                      //item.Args = append(item.Args, accArgs)
                      item.Args = accArgs
                      fmt.Printf(")", )
                  default:
                      fmt.Printf("\nERR: UNKNOWN RETSEL %s", retSelStr)
                  }
              default:
                  fmt.Printf("\nERR: UNKNOWN RETNODE %s", retNodeStr)
              }
          }
          acc = append(acc, item)
      }
      return acc
  }

  //func processSelector (selector *ast.Expr) {
  //	//selector, ok := exp.Fun.(*ast.SelectorExpr)
  //	retX, ok := selector.X.(*ast.Ident)
  //	if ok {
  //		fmt.Printf("(@ %s", retX.Name)
  //	}
  //
  //}

  func isMethodTakesCtx(pars []*ParPair) bool {
      for _, par := range pars {
          if strings.Contains(par.Type, "Context") {
              return true
          }
      }
      return false
  }

  func slurpFile(fileName string) ([]byte, error) {
      file, err := os.OpenFile(fileName, os.O_RDONLY, 0)
      if err != nil {
          return nil, errors.Wrap(err, "Can't open file '"+fileName+"'")
      }
      defer file.Close() //nolint: errcheck

      res, err := ioutil.ReadAll(file)
      if err != nil {
          return nil, errors.Wrap(err, "Can't read file '"+fileName+"'")
      }
      return res, nil
  }

  func (pf *ParsedFile) parseTypes() error {
      pf.types = make(map[string]*ast.TypeSpec)
      for _, decl := range pf.node.Decls {
          tDecl, ok := decl.(*ast.GenDecl)
          if !ok || tDecl.Tok != token.TYPE {
              continue
          }

          for _, e := range tDecl.Specs {
              typeNode := e.(*ast.TypeSpec)

              err := pf.parseTypeSpec(typeNode)
              if err != nil {
                  return err
              }
          }
      }

      return nil
  }

  func (pf *ParsedFile) parseTypeSpec(typeSpec *ast.TypeSpec) error {
      if isContractTypeSpec(typeSpec) {
          if pf.contract != "" {
              return errors.New("more than one contract in a file")
          }
          pf.contract = typeSpec.Name.Name
      } else {
          pf.types[typeSpec.Name.Name] = typeSpec
      }

      return nil
  }

  func isContractTypeSpec(typeNode *ast.TypeSpec) bool {
      baseContract := "foundation.BaseContract"
      st, ok := typeNode.Type.(*ast.StructType)
      if !ok {
          return false
      }
      if st.Fields == nil || st.Fields.NumFields() == 0 {
          return false
      }
      for _, fd := range st.Fields.List {
          if len(fd.Names) != 0 {
              continue // named struct field
          }
          selectField, ok := fd.Type.(*ast.SelectorExpr)
          if !ok {
              continue
          }
          pack := selectField.X.(*ast.Ident).Name
          class := selectField.Sel.Name
          if baseContract == (pack + "." + class) {
              return true
          }
      }

      return false
  }

  func (pf *ParsedFile) parseConstructor(fd *ast.FuncDecl) error {
      name := fd.Name.Name
      if !strings.HasPrefix(name, "New") {
          return nil // doesn't look like a constructor
      }

      res := fd.Type.Results

      if res.NumFields() != 2 {
          return errors.Errorf("Constructor %q should return exactly two values", name)
      }

      if pf.typeName(res.List[1].Type) != errorType {
          return errors.Errorf("Constructor %q should return 'error'", name)
      }

      typename := pf.typeName(res.List[0].Type)
      pf.constructors[typename] = append(pf.constructors[typename], fd)

      return nil
  }

  func (pf *ParsedFile) typeName(t ast.Expr) string {
      if tmp, ok := t.(*ast.StarExpr); ok { // *type
          t = tmp.X
      }
      return pf.codeOfNode(t)
  }

  // codeOfNode returns source code of an AST node
  func (pf *ParsedFile) codeOfNode(n ast.Node) string {
      return string(pf.code[n.Pos()-1 : n.End()-1])
  }
#+END_SRC

Код для парсинга

#+BEGIN_SRC go
  ///
  //    Copyright 2019 Insolar Technologies
  //
  //    Licensed under the Apache License, Version 2.0 (the "License");
  //    you may not use this file except in compliance with the License.
  //    You may obtain a copy of the License at
  //
  //        http://www.apache.org/licenses/LICENSE-2.0
  //
  //    Unless required by applicable law or agreed to in writing, software
  //    distributed under the License is distributed on an "AS IS" BASIS,
  //    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  //    See the License for the specific language governing permissions and
  //    limitations under the License.
  ///

  package example

  import (
      "fmt"
      "time"

      "github.com/insolar/assured-ledger/ledger-core/v2/vanilla/injector"
      "github.com/insolar/assured-ledger/ledger-core/v2/vanilla/longbits"

      "github.com/insolar/assured-ledger/ledger-core/v2/conveyor/smachine"
  )

  type StateMachine3 struct {
      serviceA *ServiceAdapterA
      catalogC CatalogC
      catalogD CatalogD

      mutex   smachine.SyncLink
      testKey longbits.ByteString
      waitKey string //longbits.ByteString
      result  string
      count   int
  }

  var IterationCount uint64
  var Limiter = smachine.NewFixedSemaphore(1000, "global")

  /* -------- Declaration ------------- */

  var declarationStateMachine3 smachine.StateMachineDeclaration = &StateMachine3Declaration{}

  type StateMachine3Declaration struct {
      smachine.StateMachineDeclTemplate
  }

  func (StateMachine3Declaration) InjectDependencies(sm smachine.StateMachine, _ smachine.SlotLink, injector *injector.DependencyInjector) {
      s := sm.(*StateMachine3)
      injector.MustInject(&s.serviceA)
      injector.MustInject(&s.catalogC)
  }

  func (StateMachine3Declaration) GetInitStateFor(sm smachine.StateMachine) smachine.InitFunc {
      s := sm.(*StateMachine3)
      return s.Init
  }

  /* -------- Instance ------------- */

  func (s *StateMachine3) GetStateMachineDeclaration() smachine.StateMachineDeclaration {
      return declarationStateMachine3
  }

  func (s *StateMachine3) Init(ctx smachine.InitializationContext) smachine.StateUpdate {
      s.testKey = longbits.WrapStr("make-pair")
      fmt.Printf("init: %v | %v\n", ctx.SlotLink(), time.Now())
      return ctx.Jump(s.Start)
  }

  func (s *StateMachine3) Start(ctx smachine.ExecutionContext) smachine.StateUpdate {
      // Looking for make-pair shared object
      if v, ok := s.catalogC.TryGet(ctx, s.testKey) ; ok {
          // Make-pair found
          mySharedAccessReport := v.PrepareWithSecondPlayer(func(state *CustomSharedState) {
              // First Player is already there, I will be Second Player
              // Key for Game Object
              key := fmt.Sprintf("%p.%p", state.FirstPlayer, state.SecondPlayer)
              s.waitKey = key //longbits.ByteString(key)
          },s ).TryUse(ctx)
          return smachine.RepeatOrJumpElse(ctx, mySharedAccessReport, s.WaitForGame, s.Wrong)
      } else {
          // Make-pair not found
          report := s.catalogC.GetOrCreate(ctx, s.testKey).PrepareWithFirstPlayer(func(state *CustomSharedState) {
          }, s).TryUse(ctx)
          return smachine.RepeatOrJumpElse(ctx, report, s.WaitForSecond, s.Wrong)
      }
  }

  func (s *StateMachine3) WaitForSecond(ctx smachine.ExecutionContext) smachine.StateUpdate {
      // Waiting for Second Player on Make-pair object
      if v, ok := s.catalogC.TryGet(ctx, s.testKey) ; ok {
          switcher := false // Default: No Second player
          mySharedAccessReport := v.Prepare(func(state *CustomSharedState) {
              if "" != state.SecondPlayer {
                  switcher = true // Second player is here!
                  s.waitKey = fmt.Sprintf("%p.%p", state.FirstPlayer, state.SecondPlayer)
              } else {
              }
          }).TryUse(ctx)
          if switcher {
              // making new SharedObject for Game and BallOwner initialization
              myGameSharedStateAccessor := s.catalogD.GetOrCreate(ctx, longbits.ByteString(s.waitKey))
              mySharedAccessReport := myGameSharedStateAccessor.Prepare(func(state *GameSharedState) {
                  state.BallOwner = s // I will be owner
                  state.cnt = 0
              }).TryUse(ctx)
              // Go to Game
              return smachine.RepeatOrJumpElse(ctx, mySharedAccessReport, s.Game, s.Wrong)
          } else {
              // No second player, repeat
              return smachine.RepeatOrJumpElse(ctx, mySharedAccessReport, s.WaitForSecond, s.Wrong)
          }
      } else {
          fmt.Printf("Error (WaitForSecond): Something wrong \n")
          return ctx.Jump(s.Wrong)
      }
  }

  func (s *StateMachine3) WaitForGame(ctx smachine.ExecutionContext) smachine.StateUpdate {
      // Waiting for Game Object
      // fmt.Printf("WaitForGame: %s \n", s.waitKey)
      if v, ok := s.catalogC.TryGet(ctx, longbits.ByteString(s.waitKey)) ; ok {
          return ctx.Jump(s.Game)
      } else {
          // repeat
          // return ctx.Sleep().ThenRepeat() // - Does not works, why? [TODO]
          time.After(2*time.Second) // ...same
          return ctx.Jump(s.WaitForGame)
      }
  }

  func (s *StateMachine3) Game(ctx smachine.ExecutionContext) smachine.StateUpdate {
      fmt.Printf("Game %p \n", s)
      if v, ok := s.catalogD.TryGet(ctx, longbits.ByteString(s.waitKey)) ; ok {
          endgame := false
          mySharedAccessReport := v.Prepare(func(state *GameSharedState) {
              if s != state.BallOwner {
                  state.BallOwner = s
              }
              state.cnt += 1
              if state.cnt > 2 {
                  endgame = true
              }
          }).TryUse(ctx)
          if endgame {
              // Go to GameOver
              return smachine.RepeatOrJumpElse(ctx, mySharedAccessReport, s.GameOver, s.Wrong)
          } else {
              // repeat
              return smachine.RepeatOrJumpElse(ctx, mySharedAccessReport, s.Game, s.Wrong)
          }
      } else {
          // Impossible (let it be for dbg)
          return ctx.Jump(s.Wrong)
      }
  }

  func (s *StateMachine3) GameOver(ctx smachine.ExecutionContext) smachine.StateUpdate {
      return ctx.Stop()
      //return ctx.Jump(s.GameOver)
      //return ctx.Stop()
  }

  func (s *StateMachine3) Wrong(ctx smachine.ExecutionContext) smachine.StateUpdate {
      fmt.Printf("ErrState: WRONG!!! %p \n", s)
      return ctx.WaitAnyUntil(time.Now().Add(time.Second)).ThenJump(s.Wrong)
      //return ctx.Stop()
  }
#+END_SRC

Представление парсера

#+BEGIN_SRC go
  &{
      %!s(*ast.CommentGroup=<nil>)
      %!s(token.Pos=637) example
      [
          %!s(*ast.GenDecl=&{<nil> 654 75 661 [0xc0001308a0 0xc0001308d0 0xc000130900 0xc000130930 0xc000130960] 888})
          %!s(*ast.GenDecl=&{<nil> 891 84 0 [0xc000130990] 0})
          %!s(*ast.GenDecl=&{<nil> 1111 85 0 [0xc0000d27d0] 0})
          %!s(*ast.GenDecl=&{<nil> 1137 85 0 [0xc0000d2870] 0})
          %!s(*ast.GenDecl=&{<nil> 1237 85 0 [0xc0000d2910] 0})
          %!s(*ast.GenDecl=&{<nil> 1330 84 0 [0xc0001309f0] 0})
          %!s(*ast.FuncDecl=&{<nil> 0xc000130a80 0xc0000a97e0 0xc0000a9c40 0xc000130b40})
          %!s(*ast.FuncDecl=&{<nil> 0xc000130bd0 0xc0000a9c80 0xc0000a9ee0 0xc000130cc0})
          %!s(*ast.FuncDecl=&{<nil> 0xc000130d50 0xc0000a9f60 0xc000166020 0xc000130e10})
          %!s(*ast.FuncDecl=&{<nil> 0xc000130ea0 0xc0001660a0 0xc0001664e0 0xc000130f60})
          %!s(*ast.FuncDecl=&{<nil> 0xc000130ff0 0xc000166560 0xc000167380 0xc000131350})
          %!s(*ast.FuncDecl=&{<nil> 0xc0001313e0 0xc000167400 0xc000168620 0xc000131920})
          %!s(*ast.FuncDecl=&{<nil> 0xc0001319b0 0xc0001686a0 0xc000168d80 0xc000131b90})
          %!s(*ast.FuncDecl=&{<nil> 0xc000131c20 0xc000168e00 0xc000169b20 0xc00016c120})
          %!s(*ast.FuncDecl=&{<nil> 0xc00016c1b0 0xc000169ba0 0xc000169d80 0xc00016c270})
          %!s(*ast.FuncDecl=&{<nil> 0xc00016c300 0xc000169e00 0xc00016e240 0xc00016c3c0})
          ]
      scope 0xc00009fd90 {
          type StateMachine3
          var IterationCount
          var Limiter
          var declarationStateMachine3
          type StateMachine3Declaration
      }
      [
          %!s(*ast.ImportSpec=&{<nil> <nil> 0xc0000a9080 <nil> 0})
          %!s(*ast.ImportSpec=&{<nil> <nil> 0xc0000a90a0 <nil> 0})
          %!s(*ast.ImportSpec=&{<nil> <nil> 0xc0000a90e0 <nil> 0})
          %!s(*ast.ImportSpec=&{<nil> <nil> 0xc0000a9120 <nil> 0})
          %!s(*ast.ImportSpec=&{<nil> <nil> 0xc0000a9140 <nil> 0})
          ]
      [
          ServiceAdapterA
          CatalogC
          CatalogD
          smachine
          longbits
          string
          string
          int

          uint64
          smachine
          smachine
          smachine
          smachine
          smachine
          injector
          smachine
          smachine
          smachine
          smachine
          smachine
          longbits
          fmt
          time
          smachine
          smachine
          CustomSharedState
          fmt
          smachine
          CustomSharedState
          smachine
          smachine
          smachine
          false
          CustomSharedState
          true
          fmt
          longbits
          GameSharedState
          smachine
          smachine
          fmt
          smachine
          smachine
          longbits
          time
          time
          smachine
          smachine
          fmt
          longbits
          false
          GameSharedState
          true
          smachine
          smachine
          smachine
          smachine
          smachine
          smachine
          fmt
          time
          time
          ]
      [
          %!s(*ast.CommentGroup=
              &{[0xc0000a8e40 0xc0000a8e60 0xc0000a8e80 0xc0000a8ec0 0xc0000a8ee0 0xc0000a8f00 0xc0000a8f20 0xc0000a8f40 0xc0000a8f60 0xc0000a8f80 0xc0000a8fa0 0xc0000a8fc0 0xc0000a8fe0 0xc0000a9000 0xc0000a9020
              ]})

          %!s(*ast.CommentGroup=&{[0xc0000a93e0]})
          %!s(*ast.CommentGroup=&{[0xc0000a9600]})
          %!s(*ast.CommentGroup=&{[0xc0000a9ea0]})
          %!s(*ast.CommentGroup=&{[0xc000166660]})
          %!s(*ast.CommentGroup=&{[0xc000166860]})
          %!s(*ast.CommentGroup=&{[0xc0001669a0 0xc0001669c0]})
          %!s(*ast.CommentGroup=&{[0xc000166c00]})
          %!s(*ast.CommentGroup=&{[0xc000166ec0]})
          %!s(*ast.CommentGroup=&{[0xc000167500]})
          %!s(*ast.CommentGroup=&{[0xc000167740]})
          %!s(*ast.CommentGroup=&{[0xc000167940]})
          %!s(*ast.CommentGroup=&{[0xc000167c00]})
          %!s(*ast.CommentGroup=&{[0xc000167f80]})
          %!s(*ast.CommentGroup=&{[0xc0001680c0]})
          %!s(*ast.CommentGroup=&{[0xc0001682c0]})
          %!s(*ast.CommentGroup=&{[0xc0001687a0 0xc0001687c0]})
          %!s(*ast.CommentGroup=&{[0xc000168b00 0xc000168b20]})
          %!s(*ast.CommentGroup=&{[0xc000168c40]})
          %!s(*ast.CommentGroup=&{[0xc000169620]})
          %!s(*ast.CommentGroup=&{[0xc000169800]})
          %!s(*ast.CommentGroup=&{[0xc0001699e0]})
          %!s(*ast.CommentGroup=&{[0xc000169d00 0xc000169d20]})
          %!s(*ast.CommentGroup=&{[0xc00016e1c0]})]}
#+END_SRC


* unsorted

Ковырять слоты

/home/rigidus/go/src/github.com/insolar/assured-ledger/ledger-core/v2/logicrunner/preprocessor/main.go
/home/rigidus/go/src/github.com/insolar/assured-ledger/ledger-core/v2/application/builtin/contract/account/account.go
/home/rigidus/go/src/github.com/insolar/assured-ledger/ledger-core/v2/application/builtin/contract/account/account.wrapper.go
/home/rigidus/go/src/github.com/insolar/assured-ledger/ledger-core/v2/application/builtin/proxy/account

Ruslan Zakirov Today at 3:59 PM
@kirill.ivkushkin зачем мы полностью отделяем VM от MN? скорость? масштабируемость? зачем нам нужно чтобы ВМки ходили к другу-другу за стейтами объектов в первую очередь?
5 replies
Kirill Ivkushkin  21 hours ago
чтобы масштабирование по CPU не упиралось в масштабирование по записи
Kirill Ivkushkin  21 hours ago
LMNы в первую очередь предназначены для масштабирования записи, а VNы для
масштабирования по вычислениям
Ruslan Zakirov  21 hours ago
ведь все равно упрется. мы просто хотим максимальное соотношение VN/MN увеличить, так? (edited)
Kirill Ivkushkin  21 hours ago
(1) у нас будет много объектов, к которым будет много постоянных immutable calls - да, тут будет доп нагрузка на LM для регистрации, но значительно меньше, т.к. они не выдают state
(2) и если будем поддерживать "бесплатные" (т.е. нерегистрируемые immutable) запросы, то тут вообще не будет влияния на LMки
(3) а учитывая "stateless" характер VNок, то в последнем случаем можно будет достаточно просто динамически регулировать кол-во VN (edited)
Kirill Ivkushkin  21 hours ago
ну а много immutable'ов есть почти всегда ...
