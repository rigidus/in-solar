#+STARTUP: showall indent hidestars

* Disclaimer

Этот документ создан как набор заметок, которые могут помочь (а могут и
помешать) разобраться в основных концепциях проекта Insolar.

Он может содержать фактические ошибки, неточности и даже прямую ложь в
отношении технических концепций, намерений разработчиков, сроков
реализации и сценариев использования. Используйте на свой страх и риск.

Я выкладываю его в свой частный репозиторий для целей совместного
редактирования, чтобы любое заинтересованное лицо могло вносить свои
уточнения и исправлять ошибки.

Все написанное может не совпадать с позицией компании Insolar и является
частным мнением (или заблуждением) автора и/или контрибьюторов

* Overview
** Structure

Из чего состоит Insolar - это список концепций, каждую из которых нужно
рассмотреть.

- Platform Core
  - Network
    - Infrastructure Layer
    - Nodes (with Roles)
    - Pulses
    - Consensus (Optimized BFT)
  - Ledger
    - LightMaterial
    - HeavyMaterial
    - Lifelines / sidelines - Последовательности записей, представляющих
      состояния объектов, которые создаются умными контрактами
    - jets / jet drops - логические единицы хранения, сформированные из lifelines
    - short/long term storage (for jets)
  - VM
  - Contracts
  - Request
  - Platform API
    - Smart Contracts API
    - Business Logic API
    - Observer API
  - Observer
- Business Foundations
  - Domains (supercontract)
    - Domain Rules
  - Toolkuts
- Applications
- External Services

** Принципы

- Everything is SmartContract
- One Executor - Many Validators
- Dynamic consensus: separation of network (nodes) and business
  (contracts) consensuses
- Use different blockchain styles to fit for purpose: one object-one
  chain for object’s lifeline and sidelines, sharded chains for block
  building, block-based chains for storage units
- Different roles (players) in the Insolar Ecosystem: resource providers,
  application developers, application consumers, Insolar
  Foundation. Different incentives & staking & liabilities

* С чего начать объяснять
** С кейсов
*** START Delivery

~Клиент~ хочет доставить груз ~Получателю~. Для этого ~Клиент~ обращатся
к ~Посреднику~, который аггрегирует предложения от ~Перевозчиков~ и
предоставляет их ~Клиенту~.

~Клиент~ выбирает предложение (или отказывается от выбора - тогда на этом
все заканчивается) и заключает сделку. Теперь у ~Перевозчика~ есть
обязательство выполнить условия сделки: доставить ~Груз~ ~Получателю~.

Отсюда возможны развилки
- (happy-case) ~Получатель~ подтвержает получение ~Груза~. Стороны
  получают свои fees.
- ~Клиент~ отказывается от сделки. Тут могут быть какие-то штрафы
- ~Получатель~ недоволен исполнением сделки. ~Груз~ поврежден или не
  доставлен - как тут происходит решение спора?
- Истек тайм-аут. Происходит действие по умолчанию (груз доставлен скорее
  всего)

[TODO:gmm] - Валидировать у Кирила

*** Transfer

Инициатором перевода денег является пользователь. Чтобы сделать перевод
он обращается к кошельку (~Wallet~), который является веб или мобильным
приложением.

Чтобы сделать перевод нужно:
- PrivKey
- Addr From
- Addr To

Wallet обращается к платформе через API, это называется ~Request~? На
самом деле он должен обратиться к одной из ~Node~ с ролью
~Virtual~. Тогда как он их получает, обновляет и т п?

~Node~ записывает ~Request~ куда?

** С обсервера и платформы (набора нод)
*** Collector
*** DB
*** API
** Дальше можно про роли нод (хранение и исполнение)

В данный момент в майнете может быть только один Heavy. Остальных сколько
угодно, но у нас пока по пять

Статические роли:
- Virtual (SmartContract Executor)
- LM
- HS
- Pulse

Динамические роли
- Executor
- Validator

По insolar-addr вычисляется Virtual Executor (VE) выбираемый из
ActiveList (динамический). ActiveList зависит от пульса - он формируется
на каждoм пульсе.

Пульс рассылается всем соседям

Отсюда мы переходим к объяснению консенсуса, но сначала:

** What is insolar-addr
** What is pulse

10 second таймслоты

На каждом пульсе:
- отправляется энтропия

*** Смена пульса

Все сложно

Jet-drops

** Consensus

4 фазы

** Discovery

На сетевом уровне

Список захардкожен в коде ноды

Как происходит добавление узлов - через дискавери
Как происходит удаление нод - она перестает отвечать на пульс или
убивается за злонамеренное поведение (еще возможны сценарии)

** Jet

Пусть у нас есть пространство контрактов 2^64 адресов
Если LME видит что данных для сохранения слишком много, то мы делим эти
данные пополам - это Jet.

** Доступ к данным
** Реквест

2 способа сформировать реквест

- из внешнего апи - запрос к кошельку
- запрос на перевод - от одной ноды к другой во время исполнения
  контракта

Реквесты сейвятся, и выполняются. Если реквест не выполнился, то его
довыполнят при этом порядок гарантируется

Транзакционный механизм

** Смартконтракт

это Go-класс, в котором есть поля, и эти поля хранятся на блокчейне как
связный список состояний - его вершина - текущее состояние

** Механизм валидации

сейчас нет.

** Конвейр (1)

Генерация документации в плантУМЛ с возможным анализом стейт-машин
Предложить технологию генерации доков

ну и соотв надо будет в этом разобраться и в первую очередь подумать, как
работать с документированием, чтобы большая часть описания оставалась в
коде

на уровне деклараций
и не надо было руками дублировать
а в идеале - если ещё можно будет анализировать структуру кода state
machine's и по нему рисовать PlantUml представления

как до кода доберёшься - расскажу суть происходящего в этом куске, и на
кой чёрт он нужен

** Филаменты

Объекты которые хранятся в JеtDrop

* Как запускается нода

#+BEGIN_SRC sh
  + export INSOLAR_LOG_FORMATTER=
  + INSOLAR_LOG_FORMATTER=
  + export INSOLAR_LOG_LEVEL=debug
  + INSOLAR_LOG_LEVEL=debug
  discovery+other nodes: 5+0
  check_working_dir() starts ...
  check_working_dir() end.
  bootstrap start
  prepare() starts ...
  stop_listening(): starts ...
  stop_listening(): stop insgorund
  grep: .artifacts/launchnet/bootstrap.yaml: Нет такого файла или каталога
  grep: .artifacts/launchnet/keeperd.yaml: Нет такого файла или каталога
  killing process using port '58090'
  stop_listening() end.
  clear_dirs() starts ...
  + rm -rfv .artifacts/launchnet/discoverynodes/
  удален каталог '.artifacts/launchnet/discoverynodes/certs'
  удален каталог '.artifacts/launchnet/discoverynodes/'
  + rm -rfv .artifacts/launchnet/logs/
  удален каталог '.artifacts/launchnet/logs/insgorund'
  удален каталог '.artifacts/launchnet/logs/discoverynodes/4'
  удален каталог '.artifacts/launchnet/logs/discoverynodes/2'
  удален каталог '.artifacts/launchnet/logs/discoverynodes/5'
  удален каталог '.artifacts/launchnet/logs/discoverynodes/1'
  удален каталог '.artifacts/launchnet/logs/discoverynodes/3'
  удален каталог '.artifacts/launchnet/logs/discoverynodes'
  удален каталог '.artifacts/launchnet/logs/'
  + rm -rfv .artifacts/launchnet/contracts
  + rm -rfv .artifacts/launchnet/logs/discoverynodes/1
  + rm -rfv .artifacts/launchnet/logs/discoverynodes/2
  + rm -rfv .artifacts/launchnet/logs/discoverynodes/3
  + rm -rfv .artifacts/launchnet/logs/discoverynodes/4
  + rm -rfv .artifacts/launchnet/logs/discoverynodes/5
  create_required_dirs() starts ...
  + mkdir -p .artifacts/launchnet/discoverynodes/certs
  + mkdir -p .artifacts/launchnet/configs/
  + mkdir -p .artifacts/launchnet/logs/insgorund/
  + touch .artifacts/launchnet/configs/insgorund_ports.txt
  + mkdir -p .artifacts/launchnet/logs/discoverynodes/1
  + mkdir -p .artifacts/launchnet/logs/discoverynodes/2
  + mkdir -p .artifacts/launchnet/logs/discoverynodes/3
  + mkdir -p .artifacts/launchnet/logs/discoverynodes/4
  + mkdir -p .artifacts/launchnet/logs/discoverynodes/5
  create_required_dirs() end.
  prepare() end.
  build binaries
  + export BUILD_TAGS
  + make build
  mkdir -p bin
  go build -o bin/insolard -tags "debug functest" -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" cmd/insolard/*.go
  go build -o bin/insolar -tags "debug functest" -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" application/cmd/insolar/*.go
  go build -o bin/insgocc -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" application/cmd/insgocc/*.go
  go build -o bin/pulsard -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" cmd/pulsard/*.go
  go build -o bin/testpulsard -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" cmd/testpulsard/*.go
  CGO_ENABLED=1 go build -o bin/insgorund -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" cmd/insgorund/*.go
  go build -o bin/healthcheck -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" cmd/healthcheck/*.go
  go build -o bin/benchmark -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" application/cmd/benchmark/*.go
  go build -o bin/apirequester -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" cmd/apirequester/*.go
  go build -o bin/pulsewatcher -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" cmd/pulsewatcher/*.go
  go build -o bin/backupmanager -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" cmd/backupmanager/*.go
  go build -o bin/keeperd -ldflags "-X github.com/insolar/insolar/version.Version=v1.3.0-13-g63229f9de -X github.com/insolar/insolar/version.BuildNumber= -X github.com/insolar/insolar/version.BuildDate=2020-01-17 -X github.com/insolar/insolar/version.BuildTime=11:28:48 -X github.com/insolar/insolar/version.GitHash=63229f9de" cmd/keeperd/*.go
  go build -o bin/heavy-badger ./cmd/heavy-badger/
  generate pulsar keys: .artifacts/launchnet/configs/pulsar_keys.json
  generate members keys in dir: .artifacts/launchnet/configs/
  generate configs
  + go run -mod=vendor scripts/generate_insolar_configs.go -p .artifacts/launchnet/configs/insgorund_ports.txt
  generate_insolar_configs.go: creates dir .artifacts/launchnet
  generate_insolar_configs.go: write to file .artifacts/launchnet/bootstrap.yaml
  generate_insolar_configs.go: write to file .artifacts/launchnet/prometheus.yaml
  generate_insolar_configs.go: writeInsolardConfigs...
  generate_insolar_configs.go: creates dir .artifacts/launchnet/discoverynodes/1
  generate_insolar_configs.go: write to file .artifacts/launchnet/discoverynodes/1/insolard.yaml
  generate_insolar_configs.go: creates dir .artifacts/launchnet/discoverynodes/2
  generate_insolar_configs.go: write to file .artifacts/launchnet/discoverynodes/2/insolard.yaml
  generate_insolar_configs.go: creates dir .artifacts/launchnet/discoverynodes/3
  generate_insolar_configs.go: write to file .artifacts/launchnet/discoverynodes/3/insolard.yaml
  generate_insolar_configs.go: creates dir .artifacts/launchnet/discoverynodes/4
  generate_insolar_configs.go: write to file .artifacts/launchnet/discoverynodes/4/insolard.yaml
  generate_insolar_configs.go: creates dir .artifacts/launchnet/discoverynodes/5
  generate_insolar_configs.go: write to file .artifacts/launchnet/discoverynodes/5/insolard.yaml
  generate_insolar_configs.go: writeInsolardConfigs...
  generate_insolar_configs.go: write to file .artifacts/launchnet/configs/insgorund_ports.txt
  generate_insolar_configs.go: write to file .artifacts/launchnet/pulsar.yaml
  generate_insolar_configs.go: write to file .artifacts/launchnet/keeperd.yaml
  generate_insolar_configs.go: creates dir .artifacts/launchnet
  generate_insolar_configs.go: write to file .artifacts/launchnet/pulsewatcher.yaml
  generate migration addresses: .artifacts/launchnet/configs/migration_addresses.json
  start bootstrap ...
  + bin/insolar bootstrap --config=.artifacts/launchnet/bootstrap.yaml --certificates-out-dir=.artifacts/launchnet/discoverynodes/certs
  + GENESIS_EXIT_CODE=0
  bootstrap log: .artifacts/launchnet/logs/bootstrap.log
  bootstrap is done
  copy_certs() starts ...
  + cp -v .artifacts/launchnet/discoverynodes/certs/discovery_cert_1.json .artifacts/launchnet/discoverynodes/1/cert.json
  '.artifacts/launchnet/discoverynodes/certs/discovery_cert_1.json' -> '.artifacts/launchnet/discoverynodes/1/cert.json'
  + cp -v .artifacts/launchnet/discoverynodes/certs/discovery_cert_2.json .artifacts/launchnet/discoverynodes/2/cert.json
  '.artifacts/launchnet/discoverynodes/certs/discovery_cert_2.json' -> '.artifacts/launchnet/discoverynodes/2/cert.json'
  + cp -v .artifacts/launchnet/discoverynodes/certs/discovery_cert_3.json .artifacts/launchnet/discoverynodes/3/cert.json
  '.artifacts/launchnet/discoverynodes/certs/discovery_cert_3.json' -> '.artifacts/launchnet/discoverynodes/3/cert.json'
  + cp -v .artifacts/launchnet/discoverynodes/certs/discovery_cert_4.json .artifacts/launchnet/discoverynodes/4/cert.json
  '.artifacts/launchnet/discoverynodes/certs/discovery_cert_4.json' -> '.artifacts/launchnet/discoverynodes/4/cert.json'
  + cp -v .artifacts/launchnet/discoverynodes/certs/discovery_cert_5.json .artifacts/launchnet/discoverynodes/5/cert.json
  '.artifacts/launchnet/discoverynodes/certs/discovery_cert_5.json' -> '.artifacts/launchnet/discoverynodes/5/cert.json'
  copy_certs() end.
  kill all processes: insgorund, insolard, pulsard
  insgorund: процесс не найден
  insolard: процесс не найден
  pulsard: процесс не найден
  start pulsar ...
     log: .artifacts/launchnet/logs/pulsar_output.log
  + mkdir -p .artifacts/launchnet/pulsar_data
  pulsar log: .artifacts/launchnet/logs/pulsar_output.log
  + bin/pulsard -c .artifacts/launchnet/pulsar.yaml
  launch_keeperd() starts ...
  launch_keeperd() end.
  start insgorund ...
  start heavy node
  heavy node started in background
  log: .artifacts/launchnet/logs/discoverynodes/1/output.log
  start discovery nodes ...
  + tee .artifacts/launchnet/logs/discoverynodes/1/output.log
  + bin/insolard --config .artifacts/launchnet/discoverynodes/1/insolard.yaml --heavy-genesis .artifacts/launchnet/configs/heavy_genesis.json
  [1]   Запущен          ${PULSARD} -c ${PULSAR_CONFIG} &> ${LAUNCHNET_LOGS_DIR}pulsar_output.log &
  [2]   Запущен          ${KEEPERD} --config=${KEEPERD_CONFIG} &> ${KEEPERD_LOG} &
  [3]   Запущен          ${INSGORUND} -l ${host}:${listen_port} --rpc ${host}:${rpc_port} --log-level=${GORUND_LOG_LEVEL} --metrics :${metrics_port} &> ${INSGORUND_LOGS}${rpc_port}.log &
  [4]-  Запущен          ${INSGORUND} -l ${host}:${listen_port} --rpc ${host}:${rpc_port} --log-level=${GORUND_LOG_LEVEL} --metrics :${metrics_port} &> ${INSGORUND_LOGS}${rpc_port}.log &
  [5]+  Запущен          $INSOLARD --config ${DISCOVERY_NODES_DATA}1/insolard.yaml --heavy-genesis ${HEAVY_GENESIS_CONFIG_FILE} 2>&1 | ${LOGROTATOR} ${DISCOVERY_NODE_LOGS}1/output.log > /dev/null &
  someone left the network
  discovery node 2 started in background
  log: .artifacts/launchnet/logs/discoverynodes/2/output.log
  + bin/insolard --config .artifacts/launchnet/discoverynodes/2/insolard.yaml
  + tee .artifacts/launchnet/logs/discoverynodes/2/output.log
  discovery node 3 started in background
  log: .artifacts/launchnet/logs/discoverynodes/3/output.log
  + tee .artifacts/launchnet/logs/discoverynodes/3/output.log
  discovery node 4 started in background
  log: .artifacts/launchnet/logs/discoverynodes/4/output.log
  + bin/insolard --config .artifacts/launchnet/discoverynodes/3/insolard.yaml
  discovery node 5 started in background
  log: .artifacts/launchnet/logs/discoverynodes/5/output.log
  + tee .artifacts/launchnet/logs/discoverynodes/4/output.log
  discovery nodes started ...
  starting pulse watcher...
  bin/pulsewatcher -c .artifacts/launchnet/pulsewatcher.yaml
  + bin/insolard --config .artifacts/launchnet/discoverynodes/4/insolard.yaml
  + tee .artifacts/launchnet/logs/discoverynodes/5/output.log
  + bin/insolard --config .artifacts/launchnet/discoverynodes/5/insolard.yaml

     URL   |        STATE         |       ID       | NETWORK PULSE |     PULSE     |    ACTIVE    | WORKING |      ROLE       |    TIMESTAMP    | UPTIME | ERROR
  +--------+----------------------+----------------+---------------+---------------+--------------+---------+-----------------+-----------------+--------+-------+
    :19001 | CompleteNetworkState |  😈 992962443  |      33020724 |      33020724 | 5 ⚽🏀😆😀😈 |       5 | Heavy           | 13:13:17.378508 | 49m30s |
    :19002 | CompleteNetworkState |  ⚽ 3309296920 |      33020724 |      33020724 | 5 ⚽🏀😆😀😈 |       5 | Virtual         | 13:13:17.378548 | 49m30s |
    :19003 | CompleteNetworkState |  😀 114004987  |      33020724 |      33020724 | 5 ⚽🏀😆😀😈 |       5 | Light           | 13:13:17.378511 | 49m30s |
    :19004 | CompleteNetworkState |  🏀 1505477843 |      33020724 |      33020724 | 5 ⚽🏀😆😀😈 |       5 | Virtual         | 13:13:17.378509 | 49m30s |
    :19005 | CompleteNetworkState |  😆 1846903875 |      33020724 |      33020724 | 5 ⚽🏀😆😀😈 |       5 | Light           | 13:13:17.378508 | 49m30s |
  +--------+----------------------+----------------+---------------+---------------+--------------+---------+-----------------+-----------------+--------+-------+
                                                                     INSOLAR STATE |    READY     |  TIME   | 13:13:17.379047 | INSOLAR UPTIME  | 49M30S |
                                                                   +---------------+--------------+---------+-----------------+-----------------+--------+-------+
  ^Cstop_listening(): starts ...
  stop_listening(): stop insgorund
  scripts/insolard/launchnet.sh: строка 126: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 117: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 127: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 117: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 126: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 117: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 127: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 117: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 132: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 117: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 136: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 117: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 137: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 117: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing process using port '58090'
  scripts/insolard/launchnet.sh: строка 97: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 95: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing process using port '58090'
  scripts/insolard/launchnet.sh: строка 97: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 95: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing process using port '33305'
  scripts/insolard/launchnet.sh: строка 97: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 95: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing pid 7805 at Пт янв 17 13:13:18 MSK 2020
  scripts/insolard/launchnet.sh: строка 98: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing process using port '33306'
  scripts/insolard/launchnet.sh: строка 97: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 95: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing pid 7834 at Пт янв 17 13:13:18 MSK 2020
  scripts/insolard/launchnet.sh: строка 98: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing process using port '33327'
  scripts/insolard/launchnet.sh: строка 97: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 95: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing pid 7824 at Пт янв 17 13:13:18 MSK 2020
  scripts/insolard/launchnet.sh: строка 98: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing process using port '33328'
  scripts/insolard/launchnet.sh: строка 97: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 95: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing pid 7838 at Пт янв 17 13:13:18 MSK 2020
  scripts/insolard/launchnet.sh: строка 98: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing process using port '7805'
  scripts/insolard/launchnet.sh: строка 97: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 95: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  killing process using port '7824'
  scripts/insolard/launchnet.sh: строка 97: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 95: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  stop_listening() end.
  kill all processes: insgorund, insolard, pulsard
  insgorund: процесс не найден
  scripts/insolard/launchnet.sh: строка 107: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 107: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  scripts/insolard/launchnet.sh: строка 107: предупреждение: run_pending_traps: неверное значение в trap_list[17]: 0x559db1372870
  FINISHING ...
  stop_listening(): starts ...
  stop_listening(): stop insgorund
  [1]   Завершён        ${PULSARD} -c ${PULSAR_CONFIG} &> ${LAUNCHNET_LOGS_DIR}pulsar_output.log
  [3]   Завершён        ${INSGORUND} -l ${host}:${listen_port} --rpc ${host}:${rpc_port} --log-level=${GORUND_LOG_LEVEL} --metrics :${metrics_port} &> ${INSGORUND_LOGS}${rpc_port}.log
  [4]   Завершён        ${INSGORUND} -l ${host}:${listen_port} --rpc ${host}:${rpc_port} --log-level=${GORUND_LOG_LEVEL} --metrics :${metrics_port} &> ${INSGORUND_LOGS}${rpc_port}.log
  [6]   Запущен          $INSOLARD --config ${DISCOVERY_NODES_DATA}${i}/insolard.yaml 2>&1 | ${LOGROTATOR} ${DISCOVERY_NODE_LOGS}${i}/output.log > /dev/null &
  [7]   Завершён        $INSOLARD --config ${DISCOVERY_NODES_DATA}${i}/insolard.yaml 2>&1 | ${LOGROTATOR} ${DISCOVERY_NODE_LOGS}${i}/output.log > /dev/null
  [8]-  Запущен          $INSOLARD --config ${DISCOVERY_NODES_DATA}${i}/insolard.yaml 2>&1 | ${LOGROTATOR} ${DISCOVERY_NODE_LOGS}${i}/output.log > /dev/null &
  [9]+  Завершён        $INSOLARD --config ${DISCOVERY_NODES_DATA}${i}/insolard.yaml 2>&1 | ${LOGROTATOR} ${DISCOVERY_NODE_LOGS}${i}/output.log > /dev/null
  someone left the network
  someone left the network
  someone left the network
  someone left the network
  someone left the network
  someone left the network
  someone left the network
  someone left the network
  killing process using port '58090'
  someone left the network
  killing process using port '58090'
  someone left the network
  killing process using port '33305'
  someone left the network
  killing process using port '33306'
  someone left the network
  killing pid 7834 at Пт янв 17 13:13:18 MSK 2020
  someone left the network
  killing process using port '33327'
  [5]   Завершён        $INSOLARD --config ${DISCOVERY_NODES_DATA}1/insolard.yaml --heavy-genesis ${HEAVY_GENESIS_CONFIG_FILE} 2>&1 | ${LOGROTATOR} ${DISCOVERY_NODE_LOGS}1/output.log > /dev/null
  someone left the network
  someone left the network
  someone left the network
  killing process using port '33328'
  someone left the network
  killing pid 7838 at Пт янв 17 13:13:18 MSK 2020
  someone left the network
  killing process using port '7805'
  someone left the network
  killing process using port '7824'
  someone left the network
  killing process using port '58090'
  someone left the network
  killing process using port '33305'
  someone left the network
  killing process using port '33306'
  someone left the network
  killing pid 7834 at Пт янв 17 13:13:18 MSK 2020
  someone left the network
  killing process using port '33327'
  someone left the network
  killing process using port '33328'
  someone left the network
  killing pid 7838 at Пт янв 17 13:13:18 MSK 2020
  someone left the network
  stop_listening() end.
  kill all processes: insgorund, insolard, pulsard
  insgorund: процесс не найден
  someone left the network
  someone left the network
  pulsard: процесс не найден
  someone left the network
#+END_SRC
* Мои задачи
** Собрать документацию используя GoDoc
** Собрать PlantUML диаграммы используя семантический анализ кода
* Что делать
** DONE Настроить GoModules в GoLand

File->Settings->GoModules->EnableGoModules(vgo)Integration:=true

** DONE Настроить go-mode в emacs
** Настроить ClickToGo
** Запускать и анализировать тесты

Запускать тесты можно прямо из GoLand но надо разобраться как они
работают из CLI

** Добавить логгер

Добавить адаптер в ~/conveyer/smashine/main.go~.

и перезагрузить среду(?)

получается следующий diff для go.mod (этот файл в .gitignore):

#+BEGIN_SRC
  diff --git a/ledger-core/v2/go.mod b/ledger-core/v2/go.mod
  index 9754299..ab17280 100644
  --- a/ledger-core/v2/go.mod
  +++ b/ledger-core/v2/go.mod
  @@ -4,11 +4,8 @@ go 1.12

   require (
          contrib.go.opencensus.io/exporter/prometheus v0.1.0
  -       github.com/AndreasBriese/bbloom v0.0.0-20190825152654-46b345b51c96 // indirect
          github.com/ThreeDotsLabs/watermill v1.0.2
  -       github.com/beorn7/perks v1.0.1 // indirect
          github.com/cheggaaa/pb/v3 v3.0.1
  -       github.com/codahale/hdrhistogram v0.0.0-20161010025455-3a0bb77429bd // indirect
          github.com/dgraph-io/badger v1.6.0-rc1.0.20191024172150-efb9d9d15d7f
          github.com/dustin/go-humanize v1.0.0
          github.com/fortytw2/leaktest v1.3.0
  @@ -23,36 +20,24 @@ require (
          github.com/grpc-ecosystem/grpc-gateway v1.9.6
          github.com/hashicorp/golang-lru v0.5.3
          github.com/insolar/component-manager v0.2.1-0.20191028200619-751a91771d2f
  -       github.com/insolar/go-actors v0.0.0-20190805151516-2fcc7bfc8ff9 // indirect
  +       github.com/insolar/insolar v1.3.0 // indirect
          github.com/insolar/rpc v1.2.2-0.20190812143745-c27e1d218f1f
          github.com/insolar/x-crypto v0.0.0-20191031140942-75fab8a325f6
          github.com/jbenet/go-base58 v0.0.0-20150317085156-6237cf65f3a6
  -       github.com/kardianos/osext v0.0.0-20190222173326-2bc1f35cddc0 // indirect
  -       github.com/magiconair/properties v1.8.1 // indirect
  -       github.com/mattn/go-colorable v0.1.4 // indirect
  -       github.com/mattn/go-isatty v0.0.9 // indirect
          github.com/olekukonko/tablewriter v0.0.1
          github.com/onrik/gomerkle v1.0.0
          github.com/opentracing/opentracing-go v1.1.0
  -       github.com/pelletier/go-toml v1.4.0 // indirect
          github.com/pkg/errors v0.8.1
          github.com/prometheus/client_golang v1.0.0
  -       github.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4 // indirect
  -       github.com/prometheus/common v0.6.0 // indirect
  -       github.com/prometheus/procfs v0.0.4 // indirect
          github.com/rs/zerolog v1.15.0
          github.com/satori/go.uuid v1.2.1-0.20181028125025-b2ce2384e17b
  -       github.com/spf13/afero v1.2.2 // indirect
          github.com/spf13/cobra v0.0.5
          github.com/spf13/jwalterweatherman v1.1.0
          github.com/spf13/pflag v1.0.3
          github.com/spf13/viper v1.4.0
          github.com/stretchr/testify v1.4.0
          github.com/tylerb/gls v0.0.0-20150407001822-e606233f194d
  -       github.com/tylerb/is v2.1.4+incompatible // indirect
  -       github.com/uber-go/atomic v1.4.0 // indirect
          github.com/uber/jaeger-client-go v2.19.0+incompatible
  -       github.com/uber/jaeger-lib v2.2.0+incompatible // indirect
          github.com/ugorji/go v1.1.4
          go.opencensus.io v0.22.0
          golang.org/x/crypto v0.0.0-20190820162420-60c769a6c586
  @@ -60,7 +45,6 @@ require (
          golang.org/x/sync v0.0.0-20190423024810-112230192c58
          golang.org/x/sys v0.0.0-20190826190057-c7b8b68b1456
          golang.org/x/tools v0.0.0-20190827205025-b29f5f60c37a
  -       gonum.org/v1/gonum v0.0.0-20191018104224-74cb7b153f2c // indirect
          google.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55
          google.golang.org/grpc v1.21.0
          gopkg.in/yaml.v2 v2.2.7
#+END_SRC

#+BEGIN_SRC go
  sm := smachine.NewSlotMachine(smachine.SlotMachineConfig{
    SlotPageSize:         1000,
    PollingPeriod:        10 * time.Millisecond,
    PollingTruncate:      1 * time.Microsecond,
    BoostNewSlotDuration: 10 * time.Millisecond,
    ScanCountLimit:       scanCountLimit,
    SlotMachineLogger:    nil, // TODO put logger adapter here
  }, signal.NextBroadcast, signal.NextBroadcast, nil)
#+END_SRC

Логгер даст трассу работы

Потом можно добавлять вызов логгера в каждое состояние. Например, в файле
~conveyor/smachine/main/example/example_1.go~ внутри func (s
*StateMachine1) ~State1(ctx smachine.ExecutionContext) smachine.StateUpdate~

** Написать use-case и smachine для него
*** Описание теста конвейера

Окей, что я понял из теста конвейера:

Первым делом мы определяем ~MachineConfig~ с набором параметров,
назначение которых мне пока непонятно.

Потом делаем фабрику, которая представляет собой функцию, которая
возвращающает <функцию стейт-машины>. Эта <функция стейт-машины> принимает
только ~ConstructionContext~, а возвращает экзэмпляр типа ~AppEventSM~,
который содержит несколько полей, назначение которых мне непонятно, и
номер пульса.

Потом мы между делом добавляем в ~MachineConfig~ логгер, непонятно почему
тут, а не когда мы опредяли ~MachineConfig~, впрочем это маловажно

Дальше мы создаем конвеер конструктором ~NewPulseConveyor~, передавая ему
~MachineConfig~, фабрику и еще несколько параметров. При создании
создается слот-машина, внутри которой есть <пул слотов> и <очередь
синхронизации>.

- ~Пул слотов~ содержит массив массивов слотов, названный ~SlotPages~ и я не
понимаю почему, но возможно это станет понятнее если посмотреть как
осуществляются манипуляции со слотами.

- ~Очередь синхронизации~ по-видимому обрабатывает сигналы и события извне,
что дает возможность слот-машине реагировать на них. Надо будет позже
внимательнее рассмотреть это "извне".

Где-то тут исходя из логики должна быть подписка на изменение пульса и
предположительно она происходит через сигналы, которые, по какой-то
причине бывают внешние и внутренние. Они являются полями конвейра и чтобы
с ними глубже разобраться надо смотреть в ~sunckit~. Кажется там много
интересного, потому что они версионируются и броадкастятся.

Еще конвейер содержит т.н. ~PulseDataManager~, там много всего и
непонятно в каких оно отношениях с сигналами.

Энивэй, после создания конвейера создается ~PulsarData~, предположительно
источник распространения пульса. Я представляю это себе как
распространение информации о изменении пульса по графу сети, но, возможно
ошибаюсь.

Потом у конвейера запускается ~Worker~

Дальше тест проверяет отсутствие ошибок на conveyor.CommitPulseChange и
засыпает.

Потом в цикле:
- ~PulsarData~ делает CreateNextPulsarPulse, после чего пульс
  подготавливается (зачем?) и коммитится
- Проверяется отстутствие ошибко при conveyor.AddInput (я пока не понимаю
  что такое Input вообще)
- Есть какой-то неясный кусок кода с GetPublishedGlobalAlias и smachine.ScheduleCallTo

И на этом вроде бы все

*** Описание слот-машины

Итак, сначала мы создаем новый сигнал, а потом слот-машину, передавая ей
конфиг и siginal.NextBroadcast в качестве коллбэков eventCallback и
SignalCallback. В конфиге идут настройки времени поллинга, размер
страницы итп)

Потом мы инжектим в слот-машину зависимости (которые в этом примере не
нужны, понадобятся в конвейере и дальнейшей эксплуатации)

Стейт-машины попадают в слот-машины с помощью метода
~SlotMachine.AddNew~, который принимает:
- контекст
- стейт-машину
- какие-то дефолтные значения
Этот метод добавляет подготавливает новый слот, записывая в него
дефольные значения, а потом через ~SlotMachineSync.AddAsyncUpdate~
по-видимому, добавляет слот в очередь SlotMachineSync.
(см. [[*%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C %D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8 %D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B8
 SlotMachine][Модель синхронизации внутри SlotMachine]])

В любом случае, ~SlotMachine.AddNew~ возвращает ~SlotLink~, который по
сути пара из айдишника и указателя на слот. Возвращаемое значение не
используется. На этом этапе у нас есть ~SlotMashine~ а в ней
~StateMachine1~.

С помощью ~sworker.NewAttachableSimpleSlotWorker~ мы инициализируем
~WorkerFactory~, что как бы намекает, что в будущем SlotWorker будет к
чему-то присоединен. Если посмотреть, то это просто указатель на
~uint32~, завернутый в тип ~AttachableSimpleSlotWorker~. Он записывается
в переменную ~WorkerFactory~, потому что этот пример  использует
примитивную затычку для Worker'а.

Еще мы получаем новый сигнал ~neverSignal~. Он будет передан в
WorkerFactory.AttachTo, видимо потому что она должна принять какой-то
сигнал. Больше он нигде не используется.

Далее идет цикл, который просто упрощенный пример цикла одного Worker`a:
- wakeupSignal := signal.Mark() - по-видимому, там внутри взводится
  сигнал с помощью CAS - уточнить <?>
- ~workerFactory.AttachTo~. Что он делает? По-видимому присоединяет к
  слот-машине функцию, которая принимает ~worker~ и передает его в
  ~SlotMachine.ScanOnce~. Внутри ScanOnce как раз и идет исполнение шагов
  стейт-машины.
  - Поэтому идем глубже и видим, что в ~AttachTo~ создается и
    инициализируется ~SimpleSlotWorker~ а потом на нем вызывается эта
    самая переданная функция
- раз в интервал (1e8/scanCountLimit) происходит консольный вывод - чтобы
  не слишком часто, видимо.
- Если ~nextPollTime~ не кончилось то мы спим, иначе
  ~wakeupSignal.Wait()~, т.е. это ожидание на сигнале
  предположительно. Не понимаю как именно оно работает внутри <?>

*** Модель синхронизации внутри SlotMachine

Есть три типа сигналов:
- signal,
- external event,
- internal event
и два типа отложенных действий
- update
- async
плюс три типа зон контроля (по типу Woroker'а)

[TODO:gmm] - распросить подробнее

* Как работают SM

У нас есть т.н. ~стейт-машина~ (SM), которая представляет собой gо-шный
класс. В этом классе есть методы состояний, которые принимают в качестве
параметра ~ExecutionContext~. Когда метод состояния хочет переключить
стейт-машину в другое состояние - он вызывает метод этого
контекста. Например, метод ctx.Jump(s.StateX) безусловно переключает
стейт-машину ~s~ в состояние ~StateX~.

Каждой стейт-машине соответствует ~слот~. Слот представляет собой все что
необходимо чтобы управлять стейт-машиной - запускать ее на выполнение,
хранить следующее состояние, и.т.п. Слоты содержаться в ~Слот-машине~,
она же ими и управляет (процессит)

~Конвейер~ же управляет множеством слот-машин.

Для того чтобы SM могли взаимодействовать друг с другом и окружением
существует ~Контексты~ (smachine/api_context.go). SM могут публиковать в
нем разделяемые ресурсы и получать к ним конкурентный доступ. При этом
нельзя просто положить в контекст что-то а потом читать и писать это,
т.к. начнутся гонки. Поэтому формируя разделяемый ресурс надо пройти
несколько шагов:
- Сначала надо определить ключ, по которому будет опубликован разделяемый
  ресурс
- Потом, используя этот ключ и контекст нужно создать разделямый объект,
  но его нельзя создать просто так, он должен принадлежать SM, поэтому
  сначала надо создать SM (например, дочернюю к текущей с помощью
  ctx.InitChild, передав ей, ей функцию, которая формирует SharedState
  нужного типа и возвращает на него указатель). Это все делает
  catalogC.GetOrCreate(), он же после этого вызывает catalogC.Get, в
  котором вызывается TryGet, в котором мы чтобы опубликовать ресурс
  - получаем ссылку на публикуемый ключ из контекста
  - возвращаем Accessor для доступа к ключу, который представляет собой
    типизированную обертку над ~SharedDataLink~, внутри которого уже
    ссылка на нетипизированные данные.
- После этого мы должны сделать ~Prepare~ над нашим типизированным
  ~Accessor-ом~. Это создает метод доступа, который будет применять
  SharedDataFunc к линку. Prepare возвращает ~SharedDataAceessor~
- Потом мы делаем TryUse. Где-то здесь я пока остановился [TODO:gmm]


всё, что тебе надо использовать - это контексты (smachine/api_context.go)
и механизмы для взаимодействия SM (smachine/api_sync.go и
smachine/api_shared_link.go)


* unsorted

Ruslan Zakirov Today at 3:59 PM
@kirill.ivkushkin зачем мы полностью отделяем VM от MN? скорость? масштабируемость? зачем нам нужно чтобы ВМки ходили к другу-другу за стейтами объектов в первую очередь?
5 replies
Kirill Ivkushkin  21 hours ago
чтобы масштабирование по CPU не упиралось в масштабирование по записи
Kirill Ivkushkin  21 hours ago
LMNы в первую очередь предназначены для масштабирования записи, а VNы для
масштабирования по вычислениям
Ruslan Zakirov  21 hours ago
ведь все равно упрется. мы просто хотим максимальное соотношение VN/MN увеличить, так? (edited)
Kirill Ivkushkin  21 hours ago
(1) у нас будет много объектов, к которым будет много постоянных immutable calls - да, тут будет доп нагрузка на LM для регистрации, но значительно меньше, т.к. они не выдают state
(2) и если будем поддерживать "бесплатные" (т.е. нерегистрируемые immutable) запросы, то тут вообще не будет влияния на LMки
(3) а учитывая "stateless" характер VNок, то в последнем случаем можно будет достаточно просто динамически регулировать кол-во VN (edited)
Kirill Ivkushkin  21 hours ago
ну а много immutable'ов есть почти всегда ...
